name: Build Installers

on:
  workflow_call:
    inputs:
      tag:
        description: 'Release tag to rename and upload assets to (skip upload if empty)'
        required: false
        type: string
        default: ''

jobs:
  build-deb:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup

      - name: Pack deb
        run: npx oclif pack deb

      - name: Rename and upload
        if: ${{ inputs.tag != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ inputs.tag }}"
          VERSION="${VERSION#v}"
          cd dist/deb
          for file in *.deb; do
            [ -f "$file" ] || continue
            arch=$(echo "$file" | grep -oE '(amd64|arm64|armel)')
            mv "$file" "linq_${VERSION}_linux-${arch}.deb"
          done
          ls -la
          for file in *.deb; do
            [ -f "$file" ] && gh release upload "${{ inputs.tag }}" "$file" --clobber
          done

  build-windows:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup

      - name: Install NSIS
        run: choco install nsis -y

      - name: Pack Windows installer
        shell: bash
        run: |
          export PATH="/c/Program Files/Git/usr/bin:/c/Program Files (x86)/NSIS:$PATH"
          npx oclif pack win

      - name: Rename and upload
        if: ${{ inputs.tag != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          VERSION="${{ inputs.tag }}"
          VERSION="${VERSION#v}"
          cd dist/win32
          for file in *.exe; do
            [ -f "$file" ] || continue
            arch=$(echo "$file" | grep -oE '(x64|x86|arm64)')
            mv "$file" "linq-${VERSION}-win-${arch}.exe"
          done
          ls -la
          for file in *.exe; do
            [ -f "$file" ] && gh release upload "${{ inputs.tag }}" "$file" --clobber
          done

  build-macos:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup

      - name: Import signing certificates
        if: ${{ inputs.tag != '' }}
        env:
          APP_CERT_BASE64: ${{ secrets.APPLE_DEV_ID_APP_CERT }}
          INSTALLER_CERT_BASE64: ${{ secrets.APPLE_DEV_ID_INSTALLER_CERT }}
          CERT_PASSWORD: ${{ secrets.APPLE_CERT_PASSWORD }}
        run: |
          KEYCHAIN_PATH="$RUNNER_TEMP/signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "$APP_CERT_BASE64" | base64 --decode > "$RUNNER_TEMP/app_cert.p12"
          echo "$INSTALLER_CERT_BASE64" | base64 --decode > "$RUNNER_TEMP/installer_cert.p12"

          security import "$RUNNER_TEMP/app_cert.p12" -P "$CERT_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security import "$RUNNER_TEMP/installer_cert.p12" -P "$CERT_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"

          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain-db

          rm -f "$RUNNER_TEMP/app_cert.p12" "$RUNNER_TEMP/installer_cert.p12"

      - name: Pack macOS installer
        run: npx oclif pack macos

      - name: Sign, notarize, and staple
        if: ${{ inputs.tag != '' }}
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          KEYCHAIN_PATH="$RUNNER_TEMP/signing.keychain-db"
          APP_IDENTITY="Developer ID Application: Linq, LLC ($APPLE_TEAM_ID)"
          INSTALLER_IDENTITY="Developer ID Installer: Linq, LLC ($APPLE_TEAM_ID)"
          ENTITLEMENTS="${GITHUB_WORKSPACE}/.github/entitlements.plist"
          PKG_DIR="$(pwd)/dist/macos"

          cd "$PKG_DIR"
          for pkg in *.pkg; do
            [ -f "$pkg" ] || continue
            PKG_PATH="${PKG_DIR}/${pkg}"
            EXPANDED="${PKG_PATH}_expanded"
            PAYLOAD_DIR=$(mktemp -d)

            # --- Step 1: Expand .pkg and sign internal binaries ---
            echo "=== Expanding $pkg ==="
            pkgutil --expand "$PKG_PATH" "$EXPANDED"

            # oclif produces flat component packages (Payload at top level)
            if [ -f "${EXPANDED}/Payload" ]; then
              COMP_DIR="$EXPANDED"
            else
              COMP_DIR=$(find "$EXPANDED" -name "*.pkg" -type d | head -1)
            fi

            if [ -z "$COMP_DIR" ] || [ ! -f "${COMP_DIR}/Payload" ]; then
              echo "ERROR: Cannot find Payload in expanded package"
              exit 1
            fi

            cd "$PAYLOAD_DIR"
            gunzip -dc < "${COMP_DIR}/Payload" | cpio -id 2>/dev/null

            echo "=== Signing Mach-O binaries ==="
            find . -type f | while read f; do
              if file "$f" | grep -qE "Mach-O"; then
                echo "  codesign: $f"
                codesign --sign "$APP_IDENTITY" \
                  --keychain "$KEYCHAIN_PATH" \
                  --options runtime \
                  --entitlements "$ENTITLEMENTS" \
                  --timestamp \
                  --force "$f"
              fi
            done

            find . | cpio -o --format odc 2>/dev/null | gzip -c > "${COMP_DIR}/Payload"
            mkbom . "${COMP_DIR}/Bom"

            cd "$PKG_DIR"
            rm -rf "$PAYLOAD_DIR"

            # --- Step 2: Flatten and sign installer ---
            echo "=== Flattening and signing installer ==="
            pkgutil --flatten "$EXPANDED" "${PKG_PATH}_unsigned"
            rm -rf "$EXPANDED"

            productsign --sign "$INSTALLER_IDENTITY" --keychain "$KEYCHAIN_PATH" "${PKG_PATH}_unsigned" "$PKG_PATH"
            rm "${PKG_PATH}_unsigned"

            # --- Step 3: Notarize ---
            echo "=== Notarizing $pkg ==="
            NOTARIZE_OUTPUT=$(xcrun notarytool submit "$PKG_PATH" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_APP_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --wait 2>&1) || true
            echo "$NOTARIZE_OUTPUT"

            SUBMISSION_ID=$(echo "$NOTARIZE_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')

            if echo "$NOTARIZE_OUTPUT" | grep -q "status: Invalid"; then
              echo "=== Notarization FAILED â€” fetching log ==="
              xcrun notarytool log "$SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_APP_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" || true
              exit 1
            fi

            # --- Step 4: Staple ---
            echo "=== Stapling $pkg ==="
            xcrun stapler staple "$PKG_PATH"
          done

      - name: Cleanup keychain
        if: ${{ always() && inputs.tag != '' }}
        run: security delete-keychain "$RUNNER_TEMP/signing.keychain-db" || true

      - name: Rename and upload
        if: ${{ inputs.tag != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ inputs.tag }}"
          VERSION="${VERSION#v}"
          cd dist/macos
          for file in *.pkg; do
            [ -f "$file" ] || continue
            arch=$(echo "$file" | grep -oE '(x64|arm64)')
            mv "$file" "linq-${VERSION}-mac-${arch}.pkg"
          done
          ls -la
          for file in *.pkg; do
            [ -f "$file" ] && gh release upload "${{ inputs.tag }}" "$file" --clobber
          done
