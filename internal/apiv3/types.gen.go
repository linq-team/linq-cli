// Package apiv3 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package apiv3

import (
	"encoding/json"
	"errors"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AttachmentStatus.
const (
	AttachmentStatusComplete AttachmentStatus = "complete"
	AttachmentStatusFailed   AttachmentStatus = "failed"
	AttachmentStatusPending  AttachmentStatus = "pending"
)

// Defines values for ChatService.
const (
	ChatServiceIMessage ChatService = "iMessage"
	ChatServiceRCS      ChatService = "RCS"
	ChatServiceSMS      ChatService = "SMS"
)

// Defines values for ChatHandleService.
const (
	ChatHandleServiceIMessage ChatHandleService = "iMessage"
	ChatHandleServiceRCS      ChatHandleService = "RCS"
	ChatHandleServiceSMS      ChatHandleService = "SMS"
)

// Defines values for ChatHandleStatus.
const (
	ChatHandleStatusActive  ChatHandleStatus = "active"
	ChatHandleStatusLeft    ChatHandleStatus = "left"
	ChatHandleStatusRemoved ChatHandleStatus = "removed"
)

// Defines values for DeliveryStatus.
const (
	DeliveryStatusDelivered DeliveryStatus = "delivered"
	DeliveryStatusFailed    DeliveryStatus = "failed"
	DeliveryStatusPending   DeliveryStatus = "pending"
	DeliveryStatusQueued    DeliveryStatus = "queued"
	DeliveryStatusSent      DeliveryStatus = "sent"
)

// Defines values for ErrorCode.
const (
	ErrorCodeAccessDenied          ErrorCode = 2005
	ErrorCodeAttachmentNotFound    ErrorCode = 2003
	ErrorCodeAttachmentNotReady    ErrorCode = 2007
	ErrorCodeCannotUpdateDM        ErrorCode = 1006
	ErrorCodeChatNotFound          ErrorCode = 2001
	ErrorCodeDatabaseConnection    ErrorCode = 3001
	ErrorCodeDatabaseQuery         ErrorCode = 3002
	ErrorCodeDeliveryFailed        ErrorCode = 4001
	ErrorCodeEventStreamConnection ErrorCode = 3003
	ErrorCodeEventStreamPublish    ErrorCode = 3004
	ErrorCodeFileDownloadFailed    ErrorCode = 5002
	ErrorCodeFileTooLarge          ErrorCode = 5005
	ErrorCodeFileUploadFailed      ErrorCode = 5001
	ErrorCodeInternalServerError   ErrorCode = 3006
	ErrorCodeInvalidFileType       ErrorCode = 5004
	ErrorCodeInvalidMessageContent ErrorCode = 1004
	ErrorCodeInvalidParameterValue ErrorCode = 1005
	ErrorCodeInvalidPhoneFormat    ErrorCode = 1002
	ErrorCodeInvalidRequestBody    ErrorCode = 1003
	ErrorCodeMessageNotFound       ErrorCode = 2002
	ErrorCodeMissingRequiredField  ErrorCode = 1001
	ErrorCodeNetworkTimeout        ErrorCode = 3005
	ErrorCodePhoneNotAvailable     ErrorCode = 4002
	ErrorCodePhonePermissionDenied ErrorCode = 2006
	ErrorCodePresignedURLFailed    ErrorCode = 5003
	ErrorCodeRateLimitExceeded     ErrorCode = 1007
	ErrorCodeRetriesExhausted      ErrorCode = 3007
	ErrorCodeServiceUnavailable    ErrorCode = 4004
	ErrorCodeUnauthorized          ErrorCode = 2004
	ErrorCodeWebhookDeliveryFailed ErrorCode = 4003
)

// Defines values for HandleService.
const (
	HandleServiceIMessage HandleService = "iMessage"
	HandleServiceRCS      HandleService = "RCS"
	HandleServiceSMS      HandleService = "SMS"
)

// Defines values for HandleStatus.
const (
	HandleStatusActive  HandleStatus = "active"
	HandleStatusLeft    HandleStatus = "left"
	HandleStatusRemoved HandleStatus = "removed"
)

// Defines values for MediaPartType.
const (
	MediaPartTypeMedia MediaPartType = "media"
)

// Defines values for MediaPartResponseType.
const (
	MediaPartResponseTypeMedia MediaPartResponseType = "media"
)

// Defines values for MessageContentPreferredService.
const (
	MessageContentPreferredServiceIMessage MessageContentPreferredService = "iMessage"
	MessageContentPreferredServiceRCS      MessageContentPreferredService = "RCS"
	MessageContentPreferredServiceSMS      MessageContentPreferredService = "SMS"
)

// Defines values for MessageEffectType.
const (
	MessageEffectTypeBubble MessageEffectType = "bubble"
	MessageEffectTypeScreen MessageEffectType = "screen"
)

// Defines values for MessageEffectsBubbleEffect.
const (
	Gentle    MessageEffectsBubbleEffect = "gentle"
	Invisible MessageEffectsBubbleEffect = "invisible"
	Loud      MessageEffectsBubbleEffect = "loud"
	Slam      MessageEffectsBubbleEffect = "slam"
)

// Defines values for MessageEffectsScreenEffect.
const (
	MessageEffectsScreenEffectBalloons      MessageEffectsScreenEffect = "balloons"
	MessageEffectsScreenEffectCelebration   MessageEffectsScreenEffect = "celebration"
	MessageEffectsScreenEffectConfetti      MessageEffectsScreenEffect = "confetti"
	MessageEffectsScreenEffectEcho          MessageEffectsScreenEffect = "echo"
	MessageEffectsScreenEffectFireworks     MessageEffectsScreenEffect = "fireworks"
	MessageEffectsScreenEffectHappyBirthday MessageEffectsScreenEffect = "happy_birthday"
	MessageEffectsScreenEffectHearts        MessageEffectsScreenEffect = "hearts"
	MessageEffectsScreenEffectLasers        MessageEffectsScreenEffect = "lasers"
	MessageEffectsScreenEffectLove          MessageEffectsScreenEffect = "love"
	MessageEffectsScreenEffectSparkles      MessageEffectsScreenEffect = "sparkles"
	MessageEffectsScreenEffectSpotlight     MessageEffectsScreenEffect = "spotlight"
)

// Defines values for MessageReceivedEventService.
const (
	MessageReceivedEventServiceIMessage MessageReceivedEventService = "iMessage"
	MessageReceivedEventServiceSMS      MessageReceivedEventService = "SMS"
)

// Defines values for MessageSentEventService.
const (
	MessageSentEventServiceIMessage MessageSentEventService = "iMessage"
	MessageSentEventServiceSMS      MessageSentEventService = "SMS"
)

// Defines values for PhoneNumberInfoType.
const (
	APPLEID PhoneNumberInfoType = "APPLE_ID"
	TWILIO  PhoneNumberInfoType = "TWILIO"
)

// Defines values for ReactionEventBaseService.
const (
	IMessage ReactionEventBaseService = "iMessage"
	RCS      ReactionEventBaseService = "RCS"
	SMS      ReactionEventBaseService = "SMS"
)

// Defines values for ReactionType.
const (
	ReactionTypeCustom    ReactionType = "custom"
	ReactionTypeDislike   ReactionType = "dislike"
	ReactionTypeEmphasize ReactionType = "emphasize"
	ReactionTypeLaugh     ReactionType = "laugh"
	ReactionTypeLike      ReactionType = "like"
	ReactionTypeLove      ReactionType = "love"
	ReactionTypeQuestion  ReactionType = "question"
)

// Defines values for RequestUploadResponseHttpMethod.
const (
	PUT RequestUploadResponseHttpMethod = "PUT"
)

// Defines values for SendReactionRequestOperation.
const (
	Add    SendReactionRequestOperation = "add"
	Remove SendReactionRequestOperation = "remove"
)

// Defines values for SupportedContentType.
const (
	ApplicationepubZip                                                   SupportedContentType = "application/epub+zip"
	Applicationmsword                                                    SupportedContentType = "application/msword"
	Applicationpdf                                                       SupportedContentType = "application/pdf"
	Applicationrtf                                                       SupportedContentType = "application/rtf"
	ApplicationvndAppleKeynote                                           SupportedContentType = "application/vnd.apple.keynote"
	ApplicationvndAppleNumbers                                           SupportedContentType = "application/vnd.apple.numbers"
	ApplicationvndApplePages                                             SupportedContentType = "application/vnd.apple.pages"
	ApplicationvndMsExcel                                                SupportedContentType = "application/vnd.ms-excel"
	ApplicationvndMsPowerpoint                                           SupportedContentType = "application/vnd.ms-powerpoint"
	ApplicationvndOpenxmlformatsOfficedocumentPresentationmlPresentation SupportedContentType = "application/vnd.openxmlformats-officedocument.presentationml.presentation"
	ApplicationvndOpenxmlformatsOfficedocumentSpreadsheetmlSheet         SupportedContentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
	ApplicationvndOpenxmlformatsOfficedocumentWordprocessingmlDocument   SupportedContentType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
	ApplicationxIworkKeynoteSffkey                                       SupportedContentType = "application/x-iwork-keynote-sffkey"
	ApplicationxIworkNumbersSffnumbers                                   SupportedContentType = "application/x-iwork-numbers-sffnumbers"
	ApplicationxIworkPagesSffpages                                       SupportedContentType = "application/x-iwork-pages-sffpages"
	ApplicationxZipCompressed                                            SupportedContentType = "application/x-zip-compressed"
	Applicationzip                                                       SupportedContentType = "application/zip"
	Audioaac                                                             SupportedContentType = "audio/aac"
	Audioaiff                                                            SupportedContentType = "audio/aiff"
	Audioamr                                                             SupportedContentType = "audio/amr"
	Audiom4a                                                             SupportedContentType = "audio/m4a"
	Audiomp3                                                             SupportedContentType = "audio/mp3"
	Audiomp4                                                             SupportedContentType = "audio/mp4"
	Audiompeg                                                            SupportedContentType = "audio/mpeg"
	Audiowav                                                             SupportedContentType = "audio/wav"
	AudioxAac                                                            SupportedContentType = "audio/x-aac"
	AudioxAiff                                                           SupportedContentType = "audio/x-aiff"
	AudioxCaf                                                            SupportedContentType = "audio/x-caf"
	AudioxM4a                                                            SupportedContentType = "audio/x-m4a"
	AudioxWav                                                            SupportedContentType = "audio/x-wav"
	Imagebmp                                                             SupportedContentType = "image/bmp"
	Imagegif                                                             SupportedContentType = "image/gif"
	Imageheic                                                            SupportedContentType = "image/heic"
	Imageheif                                                            SupportedContentType = "image/heif"
	Imagejpeg                                                            SupportedContentType = "image/jpeg"
	Imagejpg                                                             SupportedContentType = "image/jpg"
	Imagepng                                                             SupportedContentType = "image/png"
	Imagetiff                                                            SupportedContentType = "image/tiff"
	ImagexMsBmp                                                          SupportedContentType = "image/x-ms-bmp"
	Textcalendar                                                         SupportedContentType = "text/calendar"
	Textcsv                                                              SupportedContentType = "text/csv"
	Texthtml                                                             SupportedContentType = "text/html"
	Textplain                                                            SupportedContentType = "text/plain"
	Textrtf                                                              SupportedContentType = "text/rtf"
	Textvcard                                                            SupportedContentType = "text/vcard"
	TextxVcard                                                           SupportedContentType = "text/x-vcard"
	Video3gpp                                                            SupportedContentType = "video/3gpp"
	Videomp4                                                             SupportedContentType = "video/mp4"
	Videompeg                                                            SupportedContentType = "video/mpeg"
	Videoquicktime                                                       SupportedContentType = "video/quicktime"
	VideoxM4v                                                            SupportedContentType = "video/x-m4v"
)

// Defines values for TextPartType.
const (
	TextPartTypeText TextPartType = "text"
)

// Defines values for TextPartResponseType.
const (
	TextPartResponseTypeText TextPartResponseType = "text"
)

// Defines values for WebhookErrorCode.
const (
	WebhookErrorCodeDeliveryFailed   WebhookErrorCode = 4001
	WebhookErrorCodeRetriesExhausted WebhookErrorCode = 3007
)

// Defines values for SchemasMediaPartResponseType.
const (
	Media SchemasMediaPartResponseType = "media"
)

// Defines values for SchemasMessageEffectType.
const (
	SchemasMessageEffectTypeBubble SchemasMessageEffectType = "bubble"
	SchemasMessageEffectTypeScreen SchemasMessageEffectType = "screen"
)

// Defines values for SchemasTextPartResponseType.
const (
	Text SchemasTextPartResponseType = "text"
)

// Defines values for GetMessageThreadParamsOrder.
const (
	Asc  GetMessageThreadParamsOrder = "asc"
	Desc GetMessageThreadParamsOrder = "desc"
)

// AddParticipantRequest defines model for AddParticipantRequest.
type AddParticipantRequest struct {
	// Handle Phone number (E.164 format) or email address of the participant to add
	Handle string `json:"handle"`
}

// Attachment defines model for Attachment.
type Attachment struct {
	// ContentType Supported MIME types for file attachments and media URLs.
	//
	// **Images:** image/jpeg, image/png, image/gif, image/heic, image/heif, image/tiff, image/bmp
	//
	// **Videos:** video/mp4, video/quicktime, video/mpeg, video/3gpp
	//
	// **Audio:** audio/mpeg, audio/mp4, audio/x-m4a, audio/x-caf, audio/wav, audio/aiff, audio/aac, audio/amr
	//
	// **Documents:** application/pdf, text/plain, text/vcard, text/rtf, text/csv, text/html, text/calendar, application/msword, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-powerpoint, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.apple.pages, application/vnd.apple.numbers, application/vnd.apple.keynote, application/epub+zip, application/zip
	//
	// **Unsupported:** WebP, SVG, FLAC, OGG, and executable files are explicitly rejected.
	ContentType SupportedContentType `json:"content_type"`

	// CreatedAt When the attachment was created
	CreatedAt time.Time `json:"created_at"`

	// DownloadUrl URL to download the attachment
	DownloadUrl *string `json:"download_url,omitempty"`

	// Filename Original filename of the attachment
	Filename string `json:"filename"`

	// Id Unique identifier for the attachment (UUID)
	Id string `json:"id"`

	// SizeBytes Size of the attachment in bytes
	SizeBytes int64 `json:"size_bytes"`

	// Status Current upload/processing status
	Status AttachmentStatus `json:"status"`
}

// AttachmentStatus Current upload/processing status
type AttachmentStatus string

// Chat defines model for Chat.
type Chat struct {
	// CreatedAt When the chat was created
	CreatedAt time.Time `json:"created_at"`

	// DisplayName Display name for the chat
	DisplayName *string `json:"display_name"`

	// Handles List of chat participants with full handle details
	Handles []ChatHandle `json:"handles"`

	// Id Unique identifier for the chat
	Id openapi_types.UUID `json:"id"`

	// IsArchived Whether the chat is archived
	IsArchived bool `json:"is_archived"`

	// IsGroup Whether this is a group chat
	IsGroup bool `json:"is_group"`

	// Service Service type for the chat
	Service *ChatService `json:"service"`

	// UpdatedAt When the chat was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// ChatService Service type for the chat
type ChatService string

// ChatGroupIconUpdateFailedEvent Error details for chat.group_icon_update_failed webhook events.
// See [WebhookErrorCode](#/components/schemas/WebhookErrorCode) for the full error code reference.
type ChatGroupIconUpdateFailedEvent struct {
	// ChatId Chat identifier (UUID) of the group chat
	ChatId string `json:"chat_id"`

	// ErrorCode Error codes that appear in webhook failure events (`message.failed`,
	// `chat.group_name_update_failed`, `chat.group_icon_update_failed`).
	//
	// | Code | Name | Description | Recommended Action |
	// |------|------|-------------|-------------------|
	// | 3007 | `retries_exhausted` | Maximum delivery attempts exceeded | Retry after delay |
	// | 4001 | `delivery_failed` | Request could not be delivered | Check phone status |
	ErrorCode WebhookErrorCode `json:"error_code"`

	// FailedAt When the failure was detected
	FailedAt time.Time `json:"failed_at"`
}

// ChatGroupIconUpdateFailedWebhook defines model for ChatGroupIconUpdateFailedWebhook.
type ChatGroupIconUpdateFailedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Error details for chat.group_icon_update_failed webhook events.
	// See [WebhookErrorCode](#/components/schemas/WebhookErrorCode) for the full error code reference.
	Data ChatGroupIconUpdateFailedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ChatGroupIconUpdatedEvent Payload for chat.group_icon_updated webhook events
type ChatGroupIconUpdatedEvent struct {
	// ChangedByHandle A handle representing a person (phone number or email address) as a participant in a chat
	ChangedByHandle *Handle `json:"changed_by_handle,omitempty"`

	// ChatId Chat identifier (UUID) of the group chat
	ChatId string `json:"chat_id"`

	// NewValue New icon URL (null if the icon was removed)
	NewValue *string `json:"new_value"`

	// OldValue Previous icon URL (null if no previous icon)
	OldValue *string `json:"old_value"`

	// UpdatedAt When the update occurred
	UpdatedAt time.Time `json:"updated_at"`
}

// ChatGroupIconUpdatedWebhook defines model for ChatGroupIconUpdatedWebhook.
type ChatGroupIconUpdatedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for chat.group_icon_updated webhook events
	Data ChatGroupIconUpdatedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ChatGroupNameUpdateFailedEvent Error details for chat.group_name_update_failed webhook events.
// See [WebhookErrorCode](#/components/schemas/WebhookErrorCode) for the full error code reference.
type ChatGroupNameUpdateFailedEvent struct {
	// ChatId Chat identifier (UUID) of the group chat
	ChatId string `json:"chat_id"`

	// ErrorCode Error codes that appear in webhook failure events (`message.failed`,
	// `chat.group_name_update_failed`, `chat.group_icon_update_failed`).
	//
	// | Code | Name | Description | Recommended Action |
	// |------|------|-------------|-------------------|
	// | 3007 | `retries_exhausted` | Maximum delivery attempts exceeded | Retry after delay |
	// | 4001 | `delivery_failed` | Request could not be delivered | Check phone status |
	ErrorCode WebhookErrorCode `json:"error_code"`

	// FailedAt When the failure was detected
	FailedAt time.Time `json:"failed_at"`
}

// ChatGroupNameUpdateFailedWebhook defines model for ChatGroupNameUpdateFailedWebhook.
type ChatGroupNameUpdateFailedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Error details for chat.group_name_update_failed webhook events.
	// See [WebhookErrorCode](#/components/schemas/WebhookErrorCode) for the full error code reference.
	Data ChatGroupNameUpdateFailedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ChatGroupNameUpdatedEvent Payload for chat.group_name_updated webhook events
type ChatGroupNameUpdatedEvent struct {
	// ChangedByHandle A handle representing a person (phone number or email address) as a participant in a chat
	ChangedByHandle *Handle `json:"changed_by_handle,omitempty"`

	// ChatId Chat identifier (UUID) of the group chat
	ChatId string `json:"chat_id"`

	// NewValue New group name (null if the name was removed)
	NewValue *string `json:"new_value"`

	// OldValue Previous group name (null if no previous name)
	OldValue *string `json:"old_value"`

	// UpdatedAt When the update occurred
	UpdatedAt time.Time `json:"updated_at"`
}

// ChatGroupNameUpdatedWebhook defines model for ChatGroupNameUpdatedWebhook.
type ChatGroupNameUpdatedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for chat.group_name_updated webhook events
	Data ChatGroupNameUpdatedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ChatHandle defines model for ChatHandle.
type ChatHandle struct {
	// Handle Phone number (E.164) or email address of the participant
	Handle string `json:"handle"`

	// Id Unique identifier for this handle
	Id openapi_types.UUID `json:"id"`

	// IsMe Whether this handle belongs to the sender (your phone number)
	IsMe *bool `json:"is_me,omitempty"`

	// JoinedAt When this participant joined the chat
	JoinedAt time.Time `json:"joined_at"`

	// LeftAt When they left (if applicable)
	LeftAt *time.Time `json:"left_at"`

	// Service Service type (iMessage, SMS, RCS, etc.)
	Service ChatHandleService `json:"service"`

	// Status Participant status
	Status *ChatHandleStatus `json:"status,omitempty"`
}

// ChatHandleService Service type (iMessage, SMS, RCS, etc.)
type ChatHandleService string

// ChatHandleStatus Participant status
type ChatHandleStatus string

// ChatInfo defines model for ChatInfo.
type ChatInfo struct {
	// Handles Chat participants
	Handles []struct {
		// Handle Phone number or email address of the participant
		Handle   *string             `json:"handle,omitempty"`
		Id       *openapi_types.UUID `json:"id,omitempty"`
		JoinedAt *time.Time          `json:"joined_at,omitempty"`
		Service  *string             `json:"service,omitempty"`
	} `json:"handles"`

	// Id Chat identifier
	Id openapi_types.UUID `json:"id"`

	// IsActive Whether the chat is active
	IsActive bool `json:"is_active"`

	// IsGroup Whether this is a group chat
	IsGroup bool `json:"is_group"`

	// Service Messaging service
	Service string `json:"service"`
}

// CreateChatRequest defines model for CreateChatRequest.
type CreateChatRequest struct {
	// From Sender phone number in E.164 format. Must be a phone number that the
	// authenticated partner has permission to send from.
	From string `json:"from"`

	// Message Message content container. Groups all message-related fields together,
	// separating the "what" (message content) from the "where" (routing fields like from/to).
	Message MessageContent `json:"message"`

	// To Array of recipient handles (phone numbers in E.164 format or email addresses).
	// For individual chats, provide one recipient. For group chats, provide multiple.
	To []string `json:"to"`
}

// CreateChatResponse Response for creating a new chat with an initial message
type CreateChatResponse struct {
	Chat struct {
		// DisplayName Display name of the chat or primary participant
		DisplayName *string `json:"display_name"`

		// Handles List of participants in the chat
		Handles []ChatHandle `json:"handles"`

		// Id Unique identifier for the created chat (UUID)
		Id openapi_types.UUID `json:"id"`

		// IsGroup Whether this is a group chat
		IsGroup bool `json:"is_group"`

		// Message A message that was sent (used in CreateChat and SendMessage responses)
		Message SentMessage `json:"message"`

		// Service Messaging service used
		Service string `json:"service"`
	} `json:"chat"`
}

// CreateWebhookSubscriptionRequest defines model for CreateWebhookSubscriptionRequest.
type CreateWebhookSubscriptionRequest struct {
	// SubscribedEvents List of event types to subscribe to
	SubscribedEvents []string `json:"subscribed_events"`

	// TargetUrl URL where webhook events will be sent. Must be HTTPS.
	TargetUrl string `json:"target_url"`
}

// DeleteMessageRequest defines model for DeleteMessageRequest.
type DeleteMessageRequest struct {
	// ChatId ID of the chat containing the message to delete
	ChatId openapi_types.UUID `json:"chat_id"`
}

// DeliveryStatus Current delivery status of a message
type DeliveryStatus string

// ErrorCode Linq API error codes for programmatic error handling.
//
// ## Error Code Ranges
//
// | Range | Category | Description |
// |-------|----------|-------------|
// | 1xxx | Client Errors | Validation failures, malformed requests |
// | 2xxx | Resource Errors | Not found, permission denied |
// | 3xxx | Infrastructure | Processing failures, retries exhausted |
// | 4xxx | Delivery | Message delivery failures |
// | 5xxx | Attachments | File upload/download failures |
//
// ## Complete Error Code Reference
//
// ### 1xxx: Client/Request Errors
//
// | Code | Name | Description | HTTP |
// |------|------|-------------|------|
// | 1001 | `missing_required_field` | A required field is missing from the request | 400 |
// | 1002 | `invalid_phone_format` | Phone number must be in E.164 format (e.g., +14155551234) | 400 |
// | 1003 | `invalid_request_body` | Request body is malformed or contains invalid JSON | 400 |
// | 1004 | `invalid_message_content` | Message content or parts are invalid | 400 |
// | 1005 | `invalid_parameter` | A parameter value is invalid | 400 |
// | 1006 | `cannot_update_dm` | Cannot update a direct message chat (only group chats) | 400 |
// | 1007 | `rate_limit_exceeded` | Daily message limit exceeded for this partner | 429 |
//
// ### 2xxx: Resource Errors
//
// | Code | Name | Description | HTTP |
// |------|------|-------------|------|
// | 2001 | `chat_not_found` | The requested chat does not exist | 404 |
// | 2002 | `message_not_found` | The requested message does not exist | 404 |
// | 2003 | `attachment_not_found` | The requested attachment does not exist | 404 |
// | 2004 | `unauthorized` | Missing or invalid authentication token | 401 |
// | 2005 | `access_denied` | You don't have permission to access this resource | 403 |
// | 2006 | `phone_permission_denied` | You don't have permission to send from this phone number | 403 |
// | 2007 | `attachment_not_ready` | Attachment is still being processed | 404 |
//
// ### 3xxx: Infrastructure Errors
//
// | Code | Name | Description | HTTP |
// |------|------|-------------|------|
// | 3001 | `database_connection` | Database connection error (transient) | 500 |
// | 3002 | `database_query` | Database operation failed | 500 |
// | 3003 | `event_stream_connection` | Event stream connection error (transient) | 500 |
// | 3004 | `event_stream_publish` | Failed to publish to event stream | 500 |
// | 3005 | `network_timeout` | Network operation timed out | 504 |
// | 3006 | `internal_error` | Internal server error | 500 |
// | 3007 | `retries_exhausted` | Maximum delivery attempts exceeded | 500 |
//
// ### 4xxx: Delivery Errors
//
// | Code | Name | Description | HTTP |
// |------|------|-------------|------|
// | 4001 | `delivery_failed` | Request could not be delivered for processing | 500 |
// | 4002 | `phone_not_available` | Phone number is not available for this operation | 500 |
// | 4003 | `webhook_delivery_failed` | Webhook delivery to your endpoint failed | 500 |
// | 4004 | `service_unavailable` | External service is temporarily unavailable | 503 |
//
// ### 5xxx: Attachment/File Errors
//
// | Code | Name | Description | HTTP |
// |------|------|-------------|------|
// | 5001 | `file_upload_failed` | File upload failed | 500 |
// | 5002 | `file_download_failed` | File download failed | 500 |
// | 5003 | `presigned_url_failed` | Failed to generate file access URL | 500 |
// | 5004 | `invalid_file_type` | File type is not supported | 400 |
// | 5005 | `file_too_large` | File exceeds the maximum size limit | 400 |
//
// ## Handling Errors
//
// ```json
//
//	{
//	  "success": false,
//	  "error": {
//	    "status": 400,
//	    "code": 1002,
//	    "message": "Phone number must be in E.164 format"
//	  },
//	  "trace_id": "abc123"
//	}
//
// ```
//
// **Recommended retry strategy for transient errors (3xxx, 4xxx with 5xx HTTP):**
// 1. Wait 1-5 seconds, retry
// 2. If still failing, wait 30 seconds
// 3. After 3 failed attempts, log and alert
type ErrorCode int

// ErrorDetail defines model for ErrorDetail.
type ErrorDetail struct {
	// Code Linq API error codes for programmatic error handling.
	//
	// ## Error Code Ranges
	//
	// | Range | Category | Description |
	// |-------|----------|-------------|
	// | 1xxx | Client Errors | Validation failures, malformed requests |
	// | 2xxx | Resource Errors | Not found, permission denied |
	// | 3xxx | Infrastructure | Processing failures, retries exhausted |
	// | 4xxx | Delivery | Message delivery failures |
	// | 5xxx | Attachments | File upload/download failures |
	//
	// ## Complete Error Code Reference
	//
	// ### 1xxx: Client/Request Errors
	//
	// | Code | Name | Description | HTTP |
	// |------|------|-------------|------|
	// | 1001 | `missing_required_field` | A required field is missing from the request | 400 |
	// | 1002 | `invalid_phone_format` | Phone number must be in E.164 format (e.g., +14155551234) | 400 |
	// | 1003 | `invalid_request_body` | Request body is malformed or contains invalid JSON | 400 |
	// | 1004 | `invalid_message_content` | Message content or parts are invalid | 400 |
	// | 1005 | `invalid_parameter` | A parameter value is invalid | 400 |
	// | 1006 | `cannot_update_dm` | Cannot update a direct message chat (only group chats) | 400 |
	// | 1007 | `rate_limit_exceeded` | Daily message limit exceeded for this partner | 429 |
	//
	// ### 2xxx: Resource Errors
	//
	// | Code | Name | Description | HTTP |
	// |------|------|-------------|------|
	// | 2001 | `chat_not_found` | The requested chat does not exist | 404 |
	// | 2002 | `message_not_found` | The requested message does not exist | 404 |
	// | 2003 | `attachment_not_found` | The requested attachment does not exist | 404 |
	// | 2004 | `unauthorized` | Missing or invalid authentication token | 401 |
	// | 2005 | `access_denied` | You don't have permission to access this resource | 403 |
	// | 2006 | `phone_permission_denied` | You don't have permission to send from this phone number | 403 |
	// | 2007 | `attachment_not_ready` | Attachment is still being processed | 404 |
	//
	// ### 3xxx: Infrastructure Errors
	//
	// | Code | Name | Description | HTTP |
	// |------|------|-------------|------|
	// | 3001 | `database_connection` | Database connection error (transient) | 500 |
	// | 3002 | `database_query` | Database operation failed | 500 |
	// | 3003 | `event_stream_connection` | Event stream connection error (transient) | 500 |
	// | 3004 | `event_stream_publish` | Failed to publish to event stream | 500 |
	// | 3005 | `network_timeout` | Network operation timed out | 504 |
	// | 3006 | `internal_error` | Internal server error | 500 |
	// | 3007 | `retries_exhausted` | Maximum delivery attempts exceeded | 500 |
	//
	// ### 4xxx: Delivery Errors
	//
	// | Code | Name | Description | HTTP |
	// |------|------|-------------|------|
	// | 4001 | `delivery_failed` | Request could not be delivered for processing | 500 |
	// | 4002 | `phone_not_available` | Phone number is not available for this operation | 500 |
	// | 4003 | `webhook_delivery_failed` | Webhook delivery to your endpoint failed | 500 |
	// | 4004 | `service_unavailable` | External service is temporarily unavailable | 503 |
	//
	// ### 5xxx: Attachment/File Errors
	//
	// | Code | Name | Description | HTTP |
	// |------|------|-------------|------|
	// | 5001 | `file_upload_failed` | File upload failed | 500 |
	// | 5002 | `file_download_failed` | File download failed | 500 |
	// | 5003 | `presigned_url_failed` | Failed to generate file access URL | 500 |
	// | 5004 | `invalid_file_type` | File type is not supported | 400 |
	// | 5005 | `file_too_large` | File exceeds the maximum size limit | 400 |
	//
	// ## Handling Errors
	//
	// ```json
	// {
	//   "success": false,
	//   "error": {
	//     "status": 400,
	//     "code": 1002,
	//     "message": "Phone number must be in E.164 format"
	//   },
	//   "trace_id": "abc123"
	// }
	// ```
	//
	// **Recommended retry strategy for transient errors (3xxx, 4xxx with 5xx HTTP):**
	// 1. Wait 1-5 seconds, retry
	// 2. If still failing, wait 30 seconds
	// 3. After 3 failed attempts, log and alert
	Code ErrorCode `json:"code"`

	// Message Human-readable error message
	Message string `json:"message"`

	// Status HTTP status code (e.g., 400, 404, 500)
	Status int `json:"status"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error ErrorDetail `json:"error"`

	// Success Always false for error responses
	Success bool `json:"success"`

	// TraceId Unique trace ID for request tracing and debugging
	TraceId *string `json:"trace_id,omitempty"`
}

// GetMessagesResponse defines model for GetMessagesResponse.
type GetMessagesResponse struct {
	// Messages List of messages
	Messages []Message `json:"messages"`

	// NextCursor Cursor for fetching the next page of results.
	// Null if there are no more results to fetch.
	// Pass this value as the `cursor` parameter in the next request.
	NextCursor *string `json:"next_cursor"`
}

// GetThreadResponse Response containing messages in a thread with pagination
type GetThreadResponse struct {
	// Messages Messages in the thread, ordered by the specified order parameter
	Messages []ThreadMessage `json:"messages"`

	// NextCursor Cursor for fetching the next page of results (null if no more results)
	NextCursor *string `json:"next_cursor"`
}

// Handle A handle representing a person (phone number or email address) as a participant in a chat
type Handle struct {
	// Handle Phone number (E.164 format) or email address
	Handle string `json:"handle"`

	// Id Unique identifier for this handle
	Id *openapi_types.UUID `json:"id,omitempty"`

	// IsMe Whether this handle belongs to your account (your phone number)
	IsMe bool `json:"is_me"`

	// JoinedAt When this participant joined the chat
	JoinedAt *time.Time `json:"joined_at,omitempty"`

	// LeftAt When this participant left the chat (if applicable)
	LeftAt *time.Time `json:"left_at"`

	// Service Service type (iMessage, SMS, RCS)
	Service *HandleService `json:"service,omitempty"`

	// Status Participant status in the chat
	Status *HandleStatus `json:"status,omitempty"`
}

// HandleService Service type (iMessage, SMS, RCS)
type HandleService string

// HandleStatus Participant status in the chat
type HandleStatus string

// ListChatsResponse defines model for ListChatsResponse.
type ListChatsResponse struct {
	// Chats List of chats
	Chats []Chat `json:"chats"`

	// NextCursor Cursor for fetching the next page of results.
	// Null if there are no more results to fetch.
	// Pass this value as the `cursor` parameter in the next request.
	NextCursor *string `json:"next_cursor"`
}

// ListPhoneNumbersResponse defines model for ListPhoneNumbersResponse.
type ListPhoneNumbersResponse struct {
	// PhoneNumbers List of phone numbers assigned to the partner
	PhoneNumbers []PhoneNumberInfo `json:"phone_numbers"`
}

// ListWebhookSubscriptionsResponse defines model for ListWebhookSubscriptionsResponse.
type ListWebhookSubscriptionsResponse struct {
	// Subscriptions List of webhook subscriptions
	Subscriptions []WebhookSubscriptionResponse `json:"subscriptions"`
}

// MediaPart defines model for MediaPart.
type MediaPart struct {
	// AttachmentId Reference to a file pre-uploaded via `POST /v3/attachments` (optional).
	// The file is already stored, so sends using this ID skip the download step —
	// useful when sending the same file to many recipients.
	//
	// Either `url` or `attachment_id` must be provided, but not both.
	AttachmentId *openapi_types.UUID `json:"attachment_id,omitempty"`

	// IdempotencyKey Optional idempotency key for this specific message part.
	// Use this to prevent duplicate sends of the same part.
	IdempotencyKey *string `json:"idempotency_key,omitempty"`

	// Type Indicates this is a media attachment part
	Type MediaPartType `json:"type"`

	// Url Any publicly accessible HTTPS URL to the media file. The server downloads and
	// sends the file automatically — no pre-upload step required.
	//
	// **Note:** The file is downloaded on each send. If you send the same URL to
	// multiple recipients, consider using `attachment_id` instead to avoid redundant downloads.
	//
	// **Supported formats:**
	// - Images: .jpg, .jpeg, .png, .gif, .heic, .heif, .tif, .tiff, .bmp
	// - Videos: .mp4, .mov, .m4v, .mpeg, .mpg, .3gp
	// - Documents: .pdf, .txt, .rtf, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx, .pages, .numbers, .key, .epub, .zip, .html, .htm
	// - Contact & Calendar: .vcf, .ics
	//
	// **Note:** Audio files should use the dedicated `/v3/chats/{chatId}/voicememo` endpoint.
	//
	// Either `url` or `attachment_id` must be provided, but not both.
	Url *string `json:"url,omitempty"`
}

// MediaPartType Indicates this is a media attachment part
type MediaPartType string

// MediaPartResponse A media attachment part
type MediaPartResponse struct {
	// Filename Original filename
	Filename string `json:"filename"`

	// Id Unique attachment identifier
	Id openapi_types.UUID `json:"id"`

	// MimeType MIME type of the file
	MimeType string `json:"mime_type"`

	// Reactions Reactions on this message part
	Reactions *[]Reaction `json:"reactions"`

	// SizeBytes File size in bytes
	SizeBytes int `json:"size_bytes"`

	// Type Indicates this is a media attachment part
	Type MediaPartResponseType `json:"type"`

	// Url Presigned URL for downloading the attachment (expires in 1 hour).
	Url string `json:"url"`
}

// MediaPartResponseType Indicates this is a media attachment part
type MediaPartResponseType string

// Message defines model for Message.
type Message struct {
	// ChatId ID of the chat this message belongs to
	ChatId openapi_types.UUID `json:"chat_id"`

	// CreatedAt When the message was created
	CreatedAt time.Time `json:"created_at"`

	// DeliveredAt When the message was delivered
	DeliveredAt *time.Time `json:"delivered_at,omitempty"`

	// Effect iMessage effect applied to this message (screen or bubble effect)
	Effect *MessageEffect `json:"effect"`

	// From Phone number of the message sender
	From *string `json:"from,omitempty"`

	// Id Unique identifier for the message
	Id openapi_types.UUID `json:"id"`

	// IsDelivered Whether the message has been delivered
	IsDelivered bool `json:"is_delivered"`

	// IsFromMe Whether this message was sent by the authenticated user
	IsFromMe bool `json:"is_from_me"`

	// IsRead Whether the message has been read
	IsRead bool `json:"is_read"`

	// Parts Message parts in order (text and media)
	Parts *[]Message_Parts_Item `json:"parts,omitempty"`

	// ReadAt When the message was read
	ReadAt  *time.Time `json:"read_at,omitempty"`
	ReplyTo *ReplyTo   `json:"reply_to"`

	// SentAt When the message was sent
	SentAt *time.Time `json:"sent_at,omitempty"`

	// UpdatedAt When the message was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// Message_Parts_Item defines model for Message.parts.Item.
type Message_Parts_Item struct {
	union json.RawMessage
}

// MessageContent Message content container. Groups all message-related fields together,
// separating the "what" (message content) from the "where" (routing fields like from/to).
type MessageContent struct {
	// Effect iMessage effect applied to a message (screen or bubble effect)
	Effect *MessageEffect `json:"effect,omitempty"`

	// IdempotencyKey Optional idempotency key for this message.
	// Use this to prevent duplicate sends of the same message.
	IdempotencyKey *string `json:"idempotency_key,omitempty"`

	// Parts Array of message parts. Each part can be either text or media.
	// Parts are displayed in order. Text and media can be mixed.
	//
	// **Supported Media:**
	// - Images: .jpg, .jpeg, .png, .gif, .heic, .heif, .tif, .tiff, .bmp
	// - Videos: .mp4, .mov, .m4v, .mpeg, .mpg, .3gp
	// - Documents: .pdf, .txt, .rtf, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx, .pages, .numbers, .key, .epub, .zip, .html, .htm
	// - Contact & Calendar: .vcf, .ics
	//
	// **Audio Handling:**
	// - Audio files (voice memos) should use the dedicated `/v3/chats/{chatId}/voicememo` endpoint
	// - This ensures proper voice memo formatting and playback in iMessage
	//
	// **Validation Rule:** Consecutive text parts are not allowed. Text parts must
	// be separated by media parts. For example, [text, text] is invalid, but
	// [text, media, text] is valid.
	Parts []MessagePart `json:"parts"`

	// PreferredService Preferred messaging service to use for this message.
	// If not specified, uses default fallback chain: iMessage → RCS → SMS.
	// - iMessage: Enforces iMessage without fallback to RCS or SMS. Message fails if recipient doesn't support iMessage.
	// - RCS: Enforces RCS or SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
	// - SMS: Enforces SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
	PreferredService *MessageContentPreferredService `json:"preferred_service,omitempty"`

	// ReplyTo Indicates this message is a threaded reply to another message
	ReplyTo *ReplyTo `json:"reply_to,omitempty"`
}

// MessageContentPreferredService Preferred messaging service to use for this message.
// If not specified, uses default fallback chain: iMessage → RCS → SMS.
// - iMessage: Enforces iMessage without fallback to RCS or SMS. Message fails if recipient doesn't support iMessage.
// - RCS: Enforces RCS or SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
// - SMS: Enforces SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
type MessageContentPreferredService string

// MessageDeliveredEvent Payload for message.delivered webhook events
type MessageDeliveredEvent struct {
	// ChatId Chat identifier (UUID)
	ChatId *string `json:"chat_id,omitempty"`

	// DeliveredAt When the message was delivered to the recipient's device
	DeliveredAt time.Time `json:"delivered_at"`

	// MessageId Message identifier (UUID)
	MessageId *string `json:"message_id,omitempty"`
}

// MessageDeliveredWebhook defines model for MessageDeliveredWebhook.
type MessageDeliveredWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for message.delivered webhook events
	Data MessageDeliveredEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// MessageEffect iMessage effect applied to a message (screen or bubble effect)
type MessageEffect struct {
	// Name Name of the effect. Common values:
	// - Screen effects: confetti, fireworks, lasers, sparkles, celebration, hearts, love, balloons, happy_birthday, echo, spotlight
	// - Bubble effects: slam, loud, gentle, invisible
	Name *string `json:"name,omitempty"`

	// Type Type of effect
	Type *MessageEffectType `json:"type,omitempty"`
}

// MessageEffectType Type of effect
type MessageEffectType string

// MessageEffects Message effects for iMessage. Only one effect type can be applied per message.
// Screen effects play a full-screen animation. Bubble effects animate the message bubble.
type MessageEffects struct {
	// BubbleEffect Message bubble animation effect. Available bubble effects:
	// - slam: Message slams onto screen with impact
	// - loud: Message appears larger with emphasis
	// - gentle: Message fades in softly
	// - invisible: Invisible ink effect (revealed on tap)
	BubbleEffect *MessageEffectsBubbleEffect `json:"bubble_effect,omitempty"`

	// ScreenEffect Full-screen animation effect. Available screen effects:
	// - confetti: Colorful confetti falls from top of screen
	// - fireworks: Fireworks explode across the screen
	// - lasers: Laser beams scan across the screen
	// - sparkles: Sparkle/celebration effect
	// - celebration: Alias for sparkles (matches UI name)
	// - hearts: Floating hearts fill the screen
	// - love: Alias for hearts (matches UI name)
	// - balloons: Colorful balloons float up
	// - happy_birthday: Alias for balloons
	// - echo: Message text echoes/multiplies across screen
	// - spotlight: Spotlight illuminates the message
	ScreenEffect *MessageEffectsScreenEffect `json:"screen_effect,omitempty"`
}

// MessageEffectsBubbleEffect Message bubble animation effect. Available bubble effects:
// - slam: Message slams onto screen with impact
// - loud: Message appears larger with emphasis
// - gentle: Message fades in softly
// - invisible: Invisible ink effect (revealed on tap)
type MessageEffectsBubbleEffect string

// MessageEffectsScreenEffect Full-screen animation effect. Available screen effects:
// - confetti: Colorful confetti falls from top of screen
// - fireworks: Fireworks explode across the screen
// - lasers: Laser beams scan across the screen
// - sparkles: Sparkle/celebration effect
// - celebration: Alias for sparkles (matches UI name)
// - hearts: Floating hearts fill the screen
// - love: Alias for hearts (matches UI name)
// - balloons: Colorful balloons float up
// - happy_birthday: Alias for balloons
// - echo: Message text echoes/multiplies across screen
// - spotlight: Spotlight illuminates the message
type MessageEffectsScreenEffect string

// MessageFailedEvent Error details for message.failed webhook events.
// See [WebhookErrorCode](#/components/schemas/WebhookErrorCode) for the full error code reference.
type MessageFailedEvent struct {
	// ChatId Chat identifier (UUID)
	ChatId *string `json:"chat_id,omitempty"`

	// Code Error codes that appear in webhook failure events (`message.failed`,
	// `chat.group_name_update_failed`, `chat.group_icon_update_failed`).
	//
	// | Code | Name | Description | Recommended Action |
	// |------|------|-------------|-------------------|
	// | 3007 | `retries_exhausted` | Maximum delivery attempts exceeded | Retry after delay |
	// | 4001 | `delivery_failed` | Request could not be delivered | Check phone status |
	Code WebhookErrorCode `json:"code"`

	// FailedAt When the failure was detected
	FailedAt time.Time `json:"failed_at"`

	// MessageId Message identifier (UUID)
	MessageId *string `json:"message_id,omitempty"`

	// Reason Human-readable description of the failure
	Reason *string `json:"reason,omitempty"`
}

// MessageFailedWebhook defines model for MessageFailedWebhook.
type MessageFailedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Error details for message.failed webhook events.
	// See [WebhookErrorCode](#/components/schemas/WebhookErrorCode) for the full error code reference.
	Data MessageFailedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// MessagePart defines model for MessagePart.
type MessagePart struct {
	union json.RawMessage
}

// MessagePayload Message content nested within webhook events
type MessagePayload struct {
	// Effect iMessage effect applied to a message (screen or bubble animation)
	Effect *SchemasMessageEffect `json:"effect,omitempty"`

	// Id Message identifier
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Parts Message content parts (text and/or media)
	Parts *[]MessagePayload_Parts_Item `json:"parts,omitempty"`

	// ReplyTo Reference to the message this is replying to
	ReplyTo *struct {
		// MessageId The ID of the message being replied to
		MessageId *openapi_types.UUID `json:"message_id,omitempty"`

		// PartIndex Index of the message part being replied to (0-based)
		PartIndex *int32 `json:"part_index,omitempty"`
	} `json:"reply_to,omitempty"`
}

// MessagePayload_Parts_Item defines model for MessagePayload.parts.Item.
type MessagePayload_Parts_Item struct {
	union json.RawMessage
}

// MessageReadEvent Payload for message.read webhook events
type MessageReadEvent struct {
	// ChatId Chat identifier (UUID)
	ChatId *string `json:"chat_id,omitempty"`

	// MessageId Message identifier (UUID)
	MessageId *string `json:"message_id,omitempty"`

	// ReadAt When the message was read
	ReadAt time.Time `json:"read_at"`
}

// MessageReadWebhook defines model for MessageReadWebhook.
type MessageReadWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for message.read webhook events
	Data MessageReadEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// MessageReceivedEvent Payload for message.received webhook events
type MessageReceivedEvent struct {
	// ChatId Chat identifier
	ChatId *openapi_types.UUID `json:"chat_id,omitempty"`

	// From Phone number or email address of the message sender
	From *string `json:"from,omitempty"`

	// IsFromMe Whether the message was sent by us (always false for received events)
	IsFromMe *bool `json:"is_from_me,omitempty"`

	// Message Message content nested within webhook events
	Message *MessagePayload `json:"message,omitempty"`

	// ReceivedAt When the message was received
	ReceivedAt *time.Time `json:"received_at,omitempty"`

	// RecipientPhone Our phone number that received the message
	RecipientPhone *string `json:"recipient_phone,omitempty"`

	// Service Message service type
	Service *MessageReceivedEventService `json:"service,omitempty"`
}

// MessageReceivedEventService Message service type
type MessageReceivedEventService string

// MessageReceivedWebhook defines model for MessageReceivedWebhook.
type MessageReceivedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for message.received webhook events
	Data MessageReceivedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// MessageSentEvent Payload for message.sent webhook events
type MessageSentEvent struct {
	// ChatId Chat identifier
	ChatId *openapi_types.UUID `json:"chat_id,omitempty"`

	// From Phone number of the message sender (the phone number you sent from)
	From *string `json:"from,omitempty"`

	// IsFromMe Whether the message was sent by us (always true for sent events)
	IsFromMe *bool `json:"is_from_me,omitempty"`

	// Message Message content nested within webhook events
	Message *MessagePayload `json:"message,omitempty"`

	// Service Message service type
	Service *MessageSentEventService `json:"service,omitempty"`
}

// MessageSentEventService Message service type
type MessageSentEventService string

// MessageSentWebhook defines model for MessageSentWebhook.
type MessageSentWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for message.sent webhook events
	Data MessageSentEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ParticipantAddedEvent Payload for participant.added webhook events
type ParticipantAddedEvent struct {
	// AddedAt When the participant was added
	AddedAt *time.Time `json:"added_at,omitempty"`

	// ChatId Chat identifier (UUID) of the group chat
	ChatId *string `json:"chat_id,omitempty"`

	// Handle Handle (phone number or email address) of the added participant
	Handle string `json:"handle"`
}

// ParticipantAddedWebhook defines model for ParticipantAddedWebhook.
type ParticipantAddedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for participant.added webhook events
	Data ParticipantAddedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ParticipantRemovedEvent Payload for participant.removed webhook events
type ParticipantRemovedEvent struct {
	// ChatId Chat identifier (UUID) of the group chat
	ChatId *string `json:"chat_id,omitempty"`

	// Handle Handle (phone number or email address) of the removed participant
	Handle string `json:"handle"`

	// RemovedAt When the participant was removed
	RemovedAt *time.Time `json:"removed_at,omitempty"`
}

// ParticipantRemovedWebhook defines model for ParticipantRemovedWebhook.
type ParticipantRemovedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for participant.removed webhook events
	Data ParticipantRemovedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// PhoneCapabilities defines model for PhoneCapabilities.
type PhoneCapabilities struct {
	// Mms Whether MMS messaging is supported
	Mms bool `json:"mms"`

	// Sms Whether SMS messaging is supported
	Sms bool `json:"sms"`

	// Voice Whether voice calls are supported
	Voice bool `json:"voice"`
}

// PhoneNumberInfo defines model for PhoneNumberInfo.
type PhoneNumberInfo struct {
	Capabilities PhoneCapabilities `json:"capabilities"`

	// CountryCode ISO 3166-1 alpha-2 country code
	CountryCode string `json:"country_code"`

	// Id Unique identifier for the phone number
	Id openapi_types.UUID `json:"id"`

	// PhoneNumber Phone number in E.164 format
	PhoneNumber string `json:"phone_number"`

	// Type Type of phone number
	Type PhoneNumberInfoType `json:"type"`
}

// PhoneNumberInfoType Type of phone number
type PhoneNumberInfoType string

// Reaction defines model for Reaction.
type Reaction struct {
	// CustomEmoji Custom emoji if type is "custom", null otherwise
	CustomEmoji *string    `json:"custom_emoji"`
	Handle      ChatHandle `json:"handle"`

	// IsMe Whether this reaction is from the current user
	IsMe bool `json:"is_me"`

	// Type Type of reaction. Standard iMessage tapbacks are love, like, dislike, laugh, emphasize, question.
	// Custom emoji reactions have type "custom" with the actual emoji in the custom_emoji field.
	Type ReactionType `json:"type"`
}

// ReactionAddedEvent defines model for ReactionAddedEvent.
type ReactionAddedEvent = ReactionEventBase

// ReactionAddedWebhook defines model for ReactionAddedWebhook.
type ReactionAddedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for reaction.added webhook events
	Data ReactionAddedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ReactionEventBase defines model for ReactionEventBase.
type ReactionEventBase struct {
	// ChatId Chat identifier (UUID)
	ChatId *string `json:"chat_id,omitempty"`

	// CustomEmoji The actual emoji when reaction_type is "custom". Null for standard tapbacks.
	CustomEmoji *string `json:"custom_emoji"`

	// From Phone number or email address of the person who added/removed the reaction
	From *string `json:"from,omitempty"`

	// IsFromMe Whether this reaction was from the owner of the phone number (true) or from someone else (false)
	IsFromMe bool `json:"is_from_me"`

	// MessageId Message identifier (UUID) that the reaction was added to or removed from
	MessageId *string `json:"message_id,omitempty"`

	// PartIndex Index of the message part that was reacted to (0-based)
	PartIndex *int32 `json:"part_index,omitempty"`

	// ReactedAt When the reaction was added or removed
	ReactedAt *time.Time `json:"reacted_at,omitempty"`

	// ReactionType Type of reaction. Standard iMessage tapbacks are love, like, dislike, laugh, emphasize, question.
	// Custom emoji reactions have type "custom" with the actual emoji in the custom_emoji field.
	ReactionType ReactionType `json:"reaction_type"`

	// Service Message service type
	Service *ReactionEventBaseService `json:"service,omitempty"`
}

// ReactionEventBaseService Message service type
type ReactionEventBaseService string

// ReactionRemovedEvent defines model for ReactionRemovedEvent.
type ReactionRemovedEvent = ReactionEventBase

// ReactionRemovedWebhook defines model for ReactionRemovedWebhook.
type ReactionRemovedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for reaction.removed webhook events
	Data ReactionRemovedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ReactionType Type of reaction. Standard iMessage tapbacks are love, like, dislike, laugh, emphasize, question.
// Custom emoji reactions have type "custom" with the actual emoji in the custom_emoji field.
type ReactionType string

// RemoveParticipantRequest defines model for RemoveParticipantRequest.
type RemoveParticipantRequest struct {
	// Handle Phone number (E.164 format) or email address of the participant to remove
	Handle string `json:"handle"`
}

// ReplyTo Indicates this message is a threaded reply to another message
type ReplyTo struct {
	// MessageId The ID of the message to reply to
	MessageId openapi_types.UUID `json:"message_id"`

	// PartIndex The specific message part to reply to (0-based index).
	// Defaults to 0 (first part) if not provided.
	// Use this when replying to a specific part of a multipart message.
	PartIndex *int32 `json:"part_index,omitempty"`
}

// RequestUploadRequest defines model for RequestUploadRequest.
type RequestUploadRequest struct {
	// ContentType Supported MIME types for file attachments and media URLs.
	//
	// **Images:** image/jpeg, image/png, image/gif, image/heic, image/heif, image/tiff, image/bmp
	//
	// **Videos:** video/mp4, video/quicktime, video/mpeg, video/3gpp
	//
	// **Audio:** audio/mpeg, audio/mp4, audio/x-m4a, audio/x-caf, audio/wav, audio/aiff, audio/aac, audio/amr
	//
	// **Documents:** application/pdf, text/plain, text/vcard, text/rtf, text/csv, text/html, text/calendar, application/msword, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-powerpoint, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.apple.pages, application/vnd.apple.numbers, application/vnd.apple.keynote, application/epub+zip, application/zip
	//
	// **Unsupported:** WebP, SVG, FLAC, OGG, and executable files are explicitly rejected.
	ContentType SupportedContentType `json:"content_type"`

	// Filename Name of the file to upload
	Filename string `json:"filename"`

	// SizeBytes Size of the file in bytes (max 100MB)
	SizeBytes int64 `json:"size_bytes"`
}

// RequestUploadResponse defines model for RequestUploadResponse.
type RequestUploadResponse struct {
	// AttachmentId Unique identifier for the attachment (for status checks via GET /v3/attachments/{id})
	AttachmentId openapi_types.UUID `json:"attachment_id"`

	// DownloadUrl Permanent CDN URL for the file. Does not expire. Use the `attachment_id`
	// to reference this file in media parts when sending messages.
	DownloadUrl string `json:"download_url"`

	// ExpiresAt When the upload URL expires (15 minutes from now)
	ExpiresAt time.Time `json:"expires_at"`

	// HttpMethod HTTP method to use for upload (always PUT)
	HttpMethod RequestUploadResponseHttpMethod `json:"http_method"`

	// RequiredHeaders HTTP headers required for the upload request
	RequiredHeaders map[string]string `json:"required_headers"`

	// UploadUrl Presigned URL for uploading the file. PUT the raw binary file content to this URL
	// with the `required_headers`. Do not JSON-encode or multipart-wrap the body.
	// Expires after 15 minutes.
	UploadUrl string `json:"upload_url"`
}

// RequestUploadResponseHttpMethod HTTP method to use for upload (always PUT)
type RequestUploadResponseHttpMethod string

// SendMessageResponse Response for sending a message to a chat
type SendMessageResponse struct {
	// ChatId Unique identifier of the chat this message was sent to
	ChatId openapi_types.UUID `json:"chat_id"`

	// Message A message that was sent (used in CreateChat and SendMessage responses)
	Message SentMessage `json:"message"`
}

// SendMessageToChatRequest defines model for SendMessageToChatRequest.
type SendMessageToChatRequest struct {
	// Message Message content container. Groups all message-related fields together,
	// separating the "what" (message content) from the "where" (routing fields like from/to).
	Message MessageContent `json:"message"`
}

// SendReactionRequest defines model for SendReactionRequest.
type SendReactionRequest struct {
	// CustomEmoji Custom emoji string. Required when type is "custom".
	CustomEmoji *string `json:"custom_emoji,omitempty"`

	// Operation Whether to add or remove the reaction
	Operation SendReactionRequestOperation `json:"operation"`

	// PartIndex Optional index of the message part to react to.
	// If not provided, reacts to the entire message (part 0).
	PartIndex *int `json:"part_index,omitempty"`

	// Type Type of reaction. Standard iMessage tapbacks are love, like, dislike, laugh, emphasize, question.
	// Custom emoji reactions have type "custom" with the actual emoji in the custom_emoji field.
	Type ReactionType `json:"type"`
}

// SendReactionRequestOperation Whether to add or remove the reaction
type SendReactionRequestOperation string

// SendVoiceMemoResponse defines model for SendVoiceMemoResponse.
type SendVoiceMemoResponse struct {
	Chat    ChatInfo         `json:"chat"`
	Message VoiceMemoMessage `json:"message"`

	// Success Whether the voice memo was successfully queued
	Success bool `json:"success"`
}

// SendVoiceMemoToChatRequest Request to send a voice memo to a chat (chat_id provided in path)
type SendVoiceMemoToChatRequest struct {
	// From Sender phone number in E.164 format
	From string `json:"from"`

	// VoiceMemoUrl URL of the voice memo audio file. Must be a publicly accessible HTTPS URL.
	VoiceMemoUrl string `json:"voice_memo_url"`
}

// SendVoiceMemoToChatResponse Response for sending a voice memo to a chat
type SendVoiceMemoToChatResponse struct {
	VoiceMemo struct {
		Chat ChatInfo `json:"chat"`

		// CreatedAt When the voice memo was created
		CreatedAt time.Time `json:"created_at"`

		// From Sender phone number
		From string `json:"from"`

		// Id Message identifier
		Id openapi_types.UUID `json:"id"`

		// Status Current delivery status
		Status string `json:"status"`

		// To Recipient handles (phone numbers or email addresses)
		To        []string            `json:"to"`
		VoiceMemo VoiceMemoAttachment `json:"voice_memo"`
	} `json:"voice_memo"`
}

// SentMessage A message that was sent (used in CreateChat and SendMessage responses)
type SentMessage struct {
	// DeliveredAt When the message was delivered
	DeliveredAt *time.Time `json:"delivered_at"`

	// DeliveryStatus Current delivery status of a message
	DeliveryStatus DeliveryStatus `json:"delivery_status"`

	// Effect iMessage effect applied to this message (screen or bubble effect)
	Effect *MessageEffect `json:"effect"`

	// Id Message identifier (UUID)
	Id openapi_types.UUID `json:"id"`

	// IsRead Whether the message has been read
	IsRead bool `json:"is_read"`

	// Parts Message parts in order (text and media)
	Parts   []SentMessage_Parts_Item `json:"parts"`
	ReplyTo *ReplyTo                 `json:"reply_to"`

	// SentAt When the message was sent
	SentAt time.Time `json:"sent_at"`
}

// SentMessage_Parts_Item defines model for SentMessage.parts.Item.
type SentMessage_Parts_Item struct {
	union json.RawMessage
}

// SupportedContentType Supported MIME types for file attachments and media URLs.
//
// **Images:** image/jpeg, image/png, image/gif, image/heic, image/heif, image/tiff, image/bmp
//
// **Videos:** video/mp4, video/quicktime, video/mpeg, video/3gpp
//
// **Audio:** audio/mpeg, audio/mp4, audio/x-m4a, audio/x-caf, audio/wav, audio/aiff, audio/aac, audio/amr
//
// **Documents:** application/pdf, text/plain, text/vcard, text/rtf, text/csv, text/html, text/calendar, application/msword, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-powerpoint, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.apple.pages, application/vnd.apple.numbers, application/vnd.apple.keynote, application/epub+zip, application/zip
//
// **Unsupported:** WebP, SVG, FLAC, OGG, and executable files are explicitly rejected.
type SupportedContentType string

// TextPart defines model for TextPart.
type TextPart struct {
	// IdempotencyKey Optional idempotency key for this specific message part.
	// Use this to prevent duplicate sends of the same part.
	IdempotencyKey *string `json:"idempotency_key,omitempty"`

	// Type Indicates this is a text message part
	Type TextPartType `json:"type"`

	// Value The text content
	Value string `json:"value"`
}

// TextPartType Indicates this is a text message part
type TextPartType string

// TextPartResponse A text message part
type TextPartResponse struct {
	// Reactions Reactions on this message part
	Reactions *[]Reaction `json:"reactions"`

	// Type Indicates this is a text message part
	Type TextPartResponseType `json:"type"`

	// Value The text content
	Value string `json:"value"`
}

// TextPartResponseType Indicates this is a text message part
type TextPartResponseType string

// ThreadMessage A message within a thread (includes reply_to field)
type ThreadMessage struct {
	// DeliveredAt When the message was delivered
	DeliveredAt *time.Time `json:"delivered_at"`

	// DeliveryStatus Current delivery status of a message
	DeliveryStatus DeliveryStatus `json:"delivery_status"`

	// Effect iMessage effect applied to this message (screen or bubble effect)
	Effect *MessageEffect `json:"effect"`

	// Id Message identifier (UUID)
	Id openapi_types.UUID `json:"id"`

	// IsRead Whether the message has been read
	IsRead bool `json:"is_read"`

	// Parts Message parts in order (text and media)
	Parts []ThreadMessage_Parts_Item `json:"parts"`

	// ReplyTo Which message and part this is replying to (null for thread originator)
	ReplyTo *ReplyTo `json:"reply_to"`

	// SentAt When the message was sent
	SentAt time.Time `json:"sent_at"`
}

// ThreadMessage_Parts_Item defines model for ThreadMessage.parts.Item.
type ThreadMessage_Parts_Item struct {
	union json.RawMessage
}

// UpdateChatRequest defines model for UpdateChatRequest.
type UpdateChatRequest struct {
	// DisplayName New display name for the chat (group chats only)
	DisplayName *string `json:"display_name,omitempty"`

	// GroupChatIcon URL of an image to set as the group chat icon (group chats only)
	GroupChatIcon *string `json:"group_chat_icon,omitempty"`
}

// UpdateWebhookSubscriptionRequest defines model for UpdateWebhookSubscriptionRequest.
type UpdateWebhookSubscriptionRequest struct {
	// IsActive Activate or deactivate the subscription
	IsActive *bool `json:"is_active,omitempty"`

	// SubscribedEvents Updated list of event types to subscribe to
	SubscribedEvents *[]string `json:"subscribed_events,omitempty"`

	// TargetUrl New target URL for webhook events
	TargetUrl *string `json:"target_url,omitempty"`
}

// VoiceMemoAttachment defines model for VoiceMemoAttachment.
type VoiceMemoAttachment struct {
	// DurationMs Duration in milliseconds
	DurationMs *int `json:"duration_ms"`

	// Filename Original filename
	Filename string `json:"filename"`

	// Id Attachment identifier
	Id openapi_types.UUID `json:"id"`

	// MimeType Audio MIME type
	MimeType string `json:"mime_type"`

	// SizeBytes File size in bytes
	SizeBytes int `json:"size_bytes"`

	// Url CDN URL for downloading the voice memo
	Url string `json:"url"`
}

// VoiceMemoMessage defines model for VoiceMemoMessage.
type VoiceMemoMessage struct {
	// ChatId Chat identifier
	ChatId openapi_types.UUID `json:"chat_id"`

	// CreatedAt When the voice memo was created
	CreatedAt time.Time `json:"created_at"`

	// From Sender phone number
	From string `json:"from"`

	// Id Message identifier
	Id openapi_types.UUID `json:"id"`

	// Status Current delivery status
	Status string `json:"status"`

	// To Recipient handles (phone numbers or email addresses)
	To        []string            `json:"to"`
	VoiceMemo VoiceMemoAttachment `json:"voice_memo"`
}

// WebhookEnvelopeBase defines model for WebhookEnvelopeBase.
type WebhookEnvelopeBase struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// WebhookErrorCode Error codes that appear in webhook failure events (`message.failed`,
// `chat.group_name_update_failed`, `chat.group_icon_update_failed`).
//
// | Code | Name | Description | Recommended Action |
// |------|------|-------------|-------------------|
// | 3007 | `retries_exhausted` | Maximum delivery attempts exceeded | Retry after delay |
// | 4001 | `delivery_failed` | Request could not be delivered | Check phone status |
type WebhookErrorCode int

// WebhookSubscriptionCreatedResponse Response returned when creating a webhook subscription. Includes the signing secret which is only shown once.
type WebhookSubscriptionCreatedResponse struct {
	// CreatedAt When the subscription was created
	CreatedAt time.Time `json:"created_at"`

	// Id Unique identifier for the webhook subscription
	Id string `json:"id"`

	// IsActive Whether this subscription is currently active
	IsActive bool `json:"is_active"`

	// SigningSecret Secret for verifying webhook signatures. Store this securely - it cannot be retrieved again.
	SigningSecret string `json:"signing_secret"`

	// SubscribedEvents List of event types this subscription receives
	SubscribedEvents []string `json:"subscribed_events"`

	// TargetUrl URL where webhook events will be sent
	TargetUrl string `json:"target_url"`

	// UpdatedAt When the subscription was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// WebhookSubscriptionResponse defines model for WebhookSubscriptionResponse.
type WebhookSubscriptionResponse struct {
	// CreatedAt When the subscription was created
	CreatedAt time.Time `json:"created_at"`

	// Id Unique identifier for the webhook subscription
	Id string `json:"id"`

	// IsActive Whether this subscription is currently active
	IsActive bool `json:"is_active"`

	// SubscribedEvents List of event types this subscription receives
	SubscribedEvents []string `json:"subscribed_events"`

	// TargetUrl URL where webhook events will be sent
	TargetUrl string `json:"target_url"`

	// UpdatedAt When the subscription was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// SchemasMediaPartResponse A media attachment part
type SchemasMediaPartResponse struct {
	// Filename Original filename
	Filename string `json:"filename"`

	// Id Unique attachment identifier
	Id openapi_types.UUID `json:"id"`

	// MimeType MIME type of the file
	MimeType string `json:"mime_type"`

	// SizeBytes File size in bytes
	SizeBytes int `json:"size_bytes"`

	// Type Indicates this is a media attachment part
	Type SchemasMediaPartResponseType `json:"type"`

	// Url Presigned URL for downloading the attachment (expires in 1 hour).
	Url string `json:"url"`
}

// SchemasMediaPartResponseType Indicates this is a media attachment part
type SchemasMediaPartResponseType string

// SchemasMessageEffect iMessage effect applied to a message (screen or bubble animation)
type SchemasMessageEffect struct {
	// Name Effect name (confetti, fireworks, slam, gentle, etc.)
	Name *string `json:"name,omitempty"`

	// Type Effect category
	Type *SchemasMessageEffectType `json:"type,omitempty"`
}

// SchemasMessageEffectType Effect category
type SchemasMessageEffectType string

// SchemasTextPartResponse A text message part
type SchemasTextPartResponse struct {
	// Type Indicates this is a text message part
	Type SchemasTextPartResponseType `json:"type"`

	// Value The text content
	Value string `json:"value"`
}

// SchemasTextPartResponseType Indicates this is a text message part
type SchemasTextPartResponseType string

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// Forbidden defines model for Forbidden.
type Forbidden = ErrorResponse

// InternalServerError defines model for InternalServerError.
type InternalServerError = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// Unauthorized defines model for Unauthorized.
type Unauthorized = ErrorResponse

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = ErrorResponse

// ListChatsParams defines parameters for ListChats.
type ListChatsParams struct {
	// From Phone number to filter chats by. Returns all chats made from this phone number.
	// Must be in E.164 format with the `+` sign URL-encoded as `%2B` (e.g., `%2B13343284472`).
	From string `form:"from" json:"from"`

	// Limit Maximum number of chats to return per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Pagination cursor from the previous response's `next_cursor` field.
	// Omit this parameter for the first page of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetMessagesParams defines parameters for GetMessages.
type GetMessagesParams struct {
	// Cursor Pagination cursor from previous next_cursor response
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of messages to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetMessageThreadParams defines parameters for GetMessageThread.
type GetMessageThreadParams struct {
	// Cursor Pagination cursor from previous next_cursor response
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of messages to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Order Sort order for messages (asc = oldest first, desc = newest first)
	Order *GetMessageThreadParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// GetMessageThreadParamsOrder defines parameters for GetMessageThread.
type GetMessageThreadParamsOrder string

// RequestUploadJSONRequestBody defines body for RequestUpload for application/json ContentType.
type RequestUploadJSONRequestBody = RequestUploadRequest

// CreateChatJSONRequestBody defines body for CreateChat for application/json ContentType.
type CreateChatJSONRequestBody = CreateChatRequest

// UpdateChatJSONRequestBody defines body for UpdateChat for application/json ContentType.
type UpdateChatJSONRequestBody = UpdateChatRequest

// SendMessageToChatJSONRequestBody defines body for SendMessageToChat for application/json ContentType.
type SendMessageToChatJSONRequestBody = SendMessageToChatRequest

// RemoveParticipantJSONRequestBody defines body for RemoveParticipant for application/json ContentType.
type RemoveParticipantJSONRequestBody = RemoveParticipantRequest

// AddParticipantJSONRequestBody defines body for AddParticipant for application/json ContentType.
type AddParticipantJSONRequestBody = AddParticipantRequest

// SendVoiceMemoToChatJSONRequestBody defines body for SendVoiceMemoToChat for application/json ContentType.
type SendVoiceMemoToChatJSONRequestBody = SendVoiceMemoToChatRequest

// DeleteMessageJSONRequestBody defines body for DeleteMessage for application/json ContentType.
type DeleteMessageJSONRequestBody = DeleteMessageRequest

// SendReactionJSONRequestBody defines body for SendReaction for application/json ContentType.
type SendReactionJSONRequestBody = SendReactionRequest

// CreateWebhookSubscriptionJSONRequestBody defines body for CreateWebhookSubscription for application/json ContentType.
type CreateWebhookSubscriptionJSONRequestBody = CreateWebhookSubscriptionRequest

// UpdateWebhookSubscriptionJSONRequestBody defines body for UpdateWebhookSubscription for application/json ContentType.
type UpdateWebhookSubscriptionJSONRequestBody = UpdateWebhookSubscriptionRequest

// AsTextPartResponse returns the union data inside the Message_Parts_Item as a TextPartResponse
func (t Message_Parts_Item) AsTextPartResponse() (TextPartResponse, error) {
	var body TextPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextPartResponse overwrites any union data inside the Message_Parts_Item as the provided TextPartResponse
func (t *Message_Parts_Item) FromTextPartResponse(v TextPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextPartResponse performs a merge with any union data inside the Message_Parts_Item, using the provided TextPartResponse
func (t *Message_Parts_Item) MergeTextPartResponse(v TextPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMediaPartResponse returns the union data inside the Message_Parts_Item as a MediaPartResponse
func (t Message_Parts_Item) AsMediaPartResponse() (MediaPartResponse, error) {
	var body MediaPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMediaPartResponse overwrites any union data inside the Message_Parts_Item as the provided MediaPartResponse
func (t *Message_Parts_Item) FromMediaPartResponse(v MediaPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMediaPartResponse performs a merge with any union data inside the Message_Parts_Item, using the provided MediaPartResponse
func (t *Message_Parts_Item) MergeMediaPartResponse(v MediaPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Message_Parts_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Message_Parts_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTextPart returns the union data inside the MessagePart as a TextPart
func (t MessagePart) AsTextPart() (TextPart, error) {
	var body TextPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextPart overwrites any union data inside the MessagePart as the provided TextPart
func (t *MessagePart) FromTextPart(v TextPart) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextPart performs a merge with any union data inside the MessagePart, using the provided TextPart
func (t *MessagePart) MergeTextPart(v TextPart) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMediaPart returns the union data inside the MessagePart as a MediaPart
func (t MessagePart) AsMediaPart() (MediaPart, error) {
	var body MediaPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMediaPart overwrites any union data inside the MessagePart as the provided MediaPart
func (t *MessagePart) FromMediaPart(v MediaPart) error {
	v.Type = "media"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMediaPart performs a merge with any union data inside the MessagePart, using the provided MediaPart
func (t *MessagePart) MergeMediaPart(v MediaPart) error {
	v.Type = "media"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MessagePart) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MessagePart) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "media":
		return t.AsMediaPart()
	case "text":
		return t.AsTextPart()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MessagePart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MessagePart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSchemasTextPartResponse returns the union data inside the MessagePayload_Parts_Item as a SchemasTextPartResponse
func (t MessagePayload_Parts_Item) AsSchemasTextPartResponse() (SchemasTextPartResponse, error) {
	var body SchemasTextPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasTextPartResponse overwrites any union data inside the MessagePayload_Parts_Item as the provided SchemasTextPartResponse
func (t *MessagePayload_Parts_Item) FromSchemasTextPartResponse(v SchemasTextPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasTextPartResponse performs a merge with any union data inside the MessagePayload_Parts_Item, using the provided SchemasTextPartResponse
func (t *MessagePayload_Parts_Item) MergeSchemasTextPartResponse(v SchemasTextPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasMediaPartResponse returns the union data inside the MessagePayload_Parts_Item as a SchemasMediaPartResponse
func (t MessagePayload_Parts_Item) AsSchemasMediaPartResponse() (SchemasMediaPartResponse, error) {
	var body SchemasMediaPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasMediaPartResponse overwrites any union data inside the MessagePayload_Parts_Item as the provided SchemasMediaPartResponse
func (t *MessagePayload_Parts_Item) FromSchemasMediaPartResponse(v SchemasMediaPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasMediaPartResponse performs a merge with any union data inside the MessagePayload_Parts_Item, using the provided SchemasMediaPartResponse
func (t *MessagePayload_Parts_Item) MergeSchemasMediaPartResponse(v SchemasMediaPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MessagePayload_Parts_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MessagePayload_Parts_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTextPartResponse returns the union data inside the SentMessage_Parts_Item as a TextPartResponse
func (t SentMessage_Parts_Item) AsTextPartResponse() (TextPartResponse, error) {
	var body TextPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextPartResponse overwrites any union data inside the SentMessage_Parts_Item as the provided TextPartResponse
func (t *SentMessage_Parts_Item) FromTextPartResponse(v TextPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextPartResponse performs a merge with any union data inside the SentMessage_Parts_Item, using the provided TextPartResponse
func (t *SentMessage_Parts_Item) MergeTextPartResponse(v TextPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMediaPartResponse returns the union data inside the SentMessage_Parts_Item as a MediaPartResponse
func (t SentMessage_Parts_Item) AsMediaPartResponse() (MediaPartResponse, error) {
	var body MediaPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMediaPartResponse overwrites any union data inside the SentMessage_Parts_Item as the provided MediaPartResponse
func (t *SentMessage_Parts_Item) FromMediaPartResponse(v MediaPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMediaPartResponse performs a merge with any union data inside the SentMessage_Parts_Item, using the provided MediaPartResponse
func (t *SentMessage_Parts_Item) MergeMediaPartResponse(v MediaPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SentMessage_Parts_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SentMessage_Parts_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTextPartResponse returns the union data inside the ThreadMessage_Parts_Item as a TextPartResponse
func (t ThreadMessage_Parts_Item) AsTextPartResponse() (TextPartResponse, error) {
	var body TextPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextPartResponse overwrites any union data inside the ThreadMessage_Parts_Item as the provided TextPartResponse
func (t *ThreadMessage_Parts_Item) FromTextPartResponse(v TextPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextPartResponse performs a merge with any union data inside the ThreadMessage_Parts_Item, using the provided TextPartResponse
func (t *ThreadMessage_Parts_Item) MergeTextPartResponse(v TextPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMediaPartResponse returns the union data inside the ThreadMessage_Parts_Item as a MediaPartResponse
func (t ThreadMessage_Parts_Item) AsMediaPartResponse() (MediaPartResponse, error) {
	var body MediaPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMediaPartResponse overwrites any union data inside the ThreadMessage_Parts_Item as the provided MediaPartResponse
func (t *ThreadMessage_Parts_Item) FromMediaPartResponse(v MediaPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMediaPartResponse performs a merge with any union data inside the ThreadMessage_Parts_Item, using the provided MediaPartResponse
func (t *ThreadMessage_Parts_Item) MergeMediaPartResponse(v MediaPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ThreadMessage_Parts_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ThreadMessage_Parts_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
