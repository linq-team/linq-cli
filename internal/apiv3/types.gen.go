// Package apiv3 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package apiv3

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AttachmentStatus.
const (
	AttachmentStatusComplete AttachmentStatus = "complete"
	AttachmentStatusFailed   AttachmentStatus = "failed"
	AttachmentStatusPending  AttachmentStatus = "pending"
)

// Defines values for ChatService.
const (
	ChatServiceIMessage ChatService = "iMessage"
	ChatServiceRCS      ChatService = "RCS"
	ChatServiceSMS      ChatService = "SMS"
)

// Defines values for ChatHandleService.
const (
	ChatHandleServiceIMessage ChatHandleService = "iMessage"
	ChatHandleServiceRCS      ChatHandleService = "RCS"
	ChatHandleServiceSMS      ChatHandleService = "SMS"
)

// Defines values for ChatHandleStatus.
const (
	ChatHandleStatusActive  ChatHandleStatus = "active"
	ChatHandleStatusLeft    ChatHandleStatus = "left"
	ChatHandleStatusRemoved ChatHandleStatus = "removed"
)

// Defines values for DeliveryStatus.
const (
	DeliveryStatusDelivered DeliveryStatus = "delivered"
	DeliveryStatusFailed    DeliveryStatus = "failed"
	DeliveryStatusPending   DeliveryStatus = "pending"
	DeliveryStatusQueued    DeliveryStatus = "queued"
	DeliveryStatusSent      DeliveryStatus = "sent"
)

// Defines values for HandleService.
const (
	HandleServiceIMessage HandleService = "iMessage"
	HandleServiceRCS      HandleService = "RCS"
	HandleServiceSMS      HandleService = "SMS"
)

// Defines values for HandleStatus.
const (
	HandleStatusActive  HandleStatus = "active"
	HandleStatusLeft    HandleStatus = "left"
	HandleStatusRemoved HandleStatus = "removed"
)

// Defines values for MediaPartType.
const (
	MediaPartTypeMedia MediaPartType = "media"
)

// Defines values for MediaPartResponseType.
const (
	MediaPartResponseTypeMedia MediaPartResponseType = "media"
)

// Defines values for MessageContentPreferredService.
const (
	MessageContentPreferredServiceIMessage MessageContentPreferredService = "iMessage"
	MessageContentPreferredServiceRCS      MessageContentPreferredService = "RCS"
	MessageContentPreferredServiceSMS      MessageContentPreferredService = "SMS"
)

// Defines values for MessageEffectType.
const (
	MessageEffectTypeBubble MessageEffectType = "bubble"
	MessageEffectTypeScreen MessageEffectType = "screen"
)

// Defines values for MessageEffectsBubbleEffect.
const (
	Gentle    MessageEffectsBubbleEffect = "gentle"
	Invisible MessageEffectsBubbleEffect = "invisible"
	Loud      MessageEffectsBubbleEffect = "loud"
	Slam      MessageEffectsBubbleEffect = "slam"
)

// Defines values for MessageEffectsScreenEffect.
const (
	MessageEffectsScreenEffectBalloons      MessageEffectsScreenEffect = "balloons"
	MessageEffectsScreenEffectCelebration   MessageEffectsScreenEffect = "celebration"
	MessageEffectsScreenEffectConfetti      MessageEffectsScreenEffect = "confetti"
	MessageEffectsScreenEffectEcho          MessageEffectsScreenEffect = "echo"
	MessageEffectsScreenEffectFireworks     MessageEffectsScreenEffect = "fireworks"
	MessageEffectsScreenEffectHappyBirthday MessageEffectsScreenEffect = "happy_birthday"
	MessageEffectsScreenEffectHearts        MessageEffectsScreenEffect = "hearts"
	MessageEffectsScreenEffectLasers        MessageEffectsScreenEffect = "lasers"
	MessageEffectsScreenEffectLove          MessageEffectsScreenEffect = "love"
	MessageEffectsScreenEffectSparkles      MessageEffectsScreenEffect = "sparkles"
	MessageEffectsScreenEffectSpotlight     MessageEffectsScreenEffect = "spotlight"
)

// Defines values for MessageReceivedEventService.
const (
	MessageReceivedEventServiceIMessage MessageReceivedEventService = "iMessage"
	MessageReceivedEventServiceSMS      MessageReceivedEventService = "SMS"
)

// Defines values for MessageSentEventService.
const (
	MessageSentEventServiceIMessage MessageSentEventService = "iMessage"
	MessageSentEventServiceSMS      MessageSentEventService = "SMS"
)

// Defines values for PhoneNumberInfoType.
const (
	APPLEID PhoneNumberInfoType = "APPLE_ID"
	TWILIO  PhoneNumberInfoType = "TWILIO"
)

// Defines values for ReactionEventBaseService.
const (
	IMessage ReactionEventBaseService = "iMessage"
	RCS      ReactionEventBaseService = "RCS"
	SMS      ReactionEventBaseService = "SMS"
)

// Defines values for ReactionType.
const (
	ReactionTypeCustom    ReactionType = "custom"
	ReactionTypeDislike   ReactionType = "dislike"
	ReactionTypeEmphasize ReactionType = "emphasize"
	ReactionTypeLaugh     ReactionType = "laugh"
	ReactionTypeLike      ReactionType = "like"
	ReactionTypeLove      ReactionType = "love"
	ReactionTypeQuestion  ReactionType = "question"
)

// Defines values for RequestUploadResultHttpMethod.
const (
	PUT RequestUploadResultHttpMethod = "PUT"
)

// Defines values for SendReactionRequestOperation.
const (
	Add    SendReactionRequestOperation = "add"
	Remove SendReactionRequestOperation = "remove"
)

// Defines values for SupportedContentType.
const (
	ApplicationepubZip                                                   SupportedContentType = "application/epub+zip"
	Applicationmsword                                                    SupportedContentType = "application/msword"
	Applicationpdf                                                       SupportedContentType = "application/pdf"
	Applicationrtf                                                       SupportedContentType = "application/rtf"
	ApplicationvndAppleKeynote                                           SupportedContentType = "application/vnd.apple.keynote"
	ApplicationvndAppleNumbers                                           SupportedContentType = "application/vnd.apple.numbers"
	ApplicationvndApplePages                                             SupportedContentType = "application/vnd.apple.pages"
	ApplicationvndMsExcel                                                SupportedContentType = "application/vnd.ms-excel"
	ApplicationvndMsPowerpoint                                           SupportedContentType = "application/vnd.ms-powerpoint"
	ApplicationvndOpenxmlformatsOfficedocumentPresentationmlPresentation SupportedContentType = "application/vnd.openxmlformats-officedocument.presentationml.presentation"
	ApplicationvndOpenxmlformatsOfficedocumentSpreadsheetmlSheet         SupportedContentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
	ApplicationvndOpenxmlformatsOfficedocumentWordprocessingmlDocument   SupportedContentType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
	ApplicationxIworkKeynoteSffkey                                       SupportedContentType = "application/x-iwork-keynote-sffkey"
	ApplicationxIworkNumbersSffnumbers                                   SupportedContentType = "application/x-iwork-numbers-sffnumbers"
	ApplicationxIworkPagesSffpages                                       SupportedContentType = "application/x-iwork-pages-sffpages"
	ApplicationxZipCompressed                                            SupportedContentType = "application/x-zip-compressed"
	Applicationzip                                                       SupportedContentType = "application/zip"
	Audioaac                                                             SupportedContentType = "audio/aac"
	Audioaiff                                                            SupportedContentType = "audio/aiff"
	Audioamr                                                             SupportedContentType = "audio/amr"
	Audiom4a                                                             SupportedContentType = "audio/m4a"
	Audiomp3                                                             SupportedContentType = "audio/mp3"
	Audiomp4                                                             SupportedContentType = "audio/mp4"
	Audiompeg                                                            SupportedContentType = "audio/mpeg"
	Audiowav                                                             SupportedContentType = "audio/wav"
	AudioxAac                                                            SupportedContentType = "audio/x-aac"
	AudioxAiff                                                           SupportedContentType = "audio/x-aiff"
	AudioxCaf                                                            SupportedContentType = "audio/x-caf"
	AudioxM4a                                                            SupportedContentType = "audio/x-m4a"
	AudioxWav                                                            SupportedContentType = "audio/x-wav"
	Imagebmp                                                             SupportedContentType = "image/bmp"
	Imagegif                                                             SupportedContentType = "image/gif"
	Imageheic                                                            SupportedContentType = "image/heic"
	Imageheif                                                            SupportedContentType = "image/heif"
	Imagejpeg                                                            SupportedContentType = "image/jpeg"
	Imagejpg                                                             SupportedContentType = "image/jpg"
	Imagepng                                                             SupportedContentType = "image/png"
	Imagetiff                                                            SupportedContentType = "image/tiff"
	ImagexMsBmp                                                          SupportedContentType = "image/x-ms-bmp"
	Textcalendar                                                         SupportedContentType = "text/calendar"
	Textcsv                                                              SupportedContentType = "text/csv"
	Texthtml                                                             SupportedContentType = "text/html"
	Textplain                                                            SupportedContentType = "text/plain"
	Textrtf                                                              SupportedContentType = "text/rtf"
	Textvcard                                                            SupportedContentType = "text/vcard"
	TextxVcard                                                           SupportedContentType = "text/x-vcard"
	Video3gpp                                                            SupportedContentType = "video/3gpp"
	Videomp4                                                             SupportedContentType = "video/mp4"
	Videompeg                                                            SupportedContentType = "video/mpeg"
	Videoquicktime                                                       SupportedContentType = "video/quicktime"
	VideoxM4v                                                            SupportedContentType = "video/x-m4v"
)

// Defines values for TextPartType.
const (
	TextPartTypeText TextPartType = "text"
)

// Defines values for TextPartResponseType.
const (
	TextPartResponseTypeText TextPartResponseType = "text"
)

// Defines values for WebhookErrorCode.
const (
	DeliveryFailed   WebhookErrorCode = 4001
	RetriesExhausted WebhookErrorCode = 3007
)

// Defines values for SchemasMediaPartResponseType.
const (
	Media SchemasMediaPartResponseType = "media"
)

// Defines values for SchemasMessageEffectType.
const (
	SchemasMessageEffectTypeBubble SchemasMessageEffectType = "bubble"
	SchemasMessageEffectTypeScreen SchemasMessageEffectType = "screen"
)

// Defines values for SchemasTextPartResponseType.
const (
	Text SchemasTextPartResponseType = "text"
)

// Defines values for GetMessageThreadParamsOrder.
const (
	Asc  GetMessageThreadParamsOrder = "asc"
	Desc GetMessageThreadParamsOrder = "desc"
)

// AddParticipantRequest defines model for AddParticipantRequest.
type AddParticipantRequest struct {
	// Handle Phone number (E.164 format) or email address of the participant to add
	Handle string `json:"handle"`
}

// Attachment defines model for Attachment.
type Attachment struct {
	// ContentType Supported MIME types for file attachments and media URLs.
	//
	// **Images:** image/jpeg, image/png, image/gif, image/heic, image/heif, image/tiff, image/bmp
	//
	// **Videos:** video/mp4, video/quicktime, video/mpeg, video/3gpp
	//
	// **Audio:** audio/mpeg, audio/mp4, audio/x-m4a, audio/x-caf, audio/wav, audio/aiff, audio/aac, audio/amr
	//
	// **Documents:** application/pdf, text/plain, text/vcard, text/rtf, text/csv, text/html, text/calendar, application/msword, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-powerpoint, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.apple.pages, application/vnd.apple.numbers, application/vnd.apple.keynote, application/epub+zip, application/zip
	//
	// **Unsupported:** WebP, SVG, FLAC, OGG, and executable files are explicitly rejected.
	ContentType SupportedContentType `json:"content_type"`

	// CreatedAt When the attachment was created
	CreatedAt time.Time `json:"created_at"`

	// DownloadUrl URL to download the attachment
	DownloadUrl *string `json:"download_url,omitempty"`

	// Filename Original filename of the attachment
	Filename string `json:"filename"`

	// Id Unique identifier for the attachment (UUID)
	Id string `json:"id"`

	// SizeBytes Size of the attachment in bytes
	SizeBytes int64 `json:"size_bytes"`

	// Status Current upload/processing status
	Status AttachmentStatus `json:"status"`
}

// AttachmentStatus Current upload/processing status
type AttachmentStatus string

// Chat defines model for Chat.
type Chat struct {
	// CreatedAt When the chat was created
	CreatedAt time.Time `json:"created_at"`

	// DisplayName Display name for the chat
	DisplayName *string `json:"display_name"`

	// Handles List of chat participants with full handle details
	Handles []ChatHandle `json:"handles"`

	// Id Unique identifier for the chat
	Id openapi_types.UUID `json:"id"`

	// IsArchived Whether the chat is archived
	IsArchived bool `json:"is_archived"`

	// IsGroup Whether this is a group chat
	IsGroup bool `json:"is_group"`

	// Service Service type for the chat
	Service *ChatService `json:"service"`

	// UpdatedAt When the chat was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// ChatService Service type for the chat
type ChatService string

// ChatGroupIconUpdateFailedEvent Error details for chat.group_icon_update_failed webhook events.
// See [WebhookErrorCode](#/components/schemas/WebhookErrorCode) for the full error code reference.
type ChatGroupIconUpdateFailedEvent struct {
	// ChatId Chat identifier (UUID) of the group chat
	ChatId string `json:"chat_id"`

	// ErrorCode Error codes that appear in webhook failure events (`message.failed`,
	// `chat.group_name_update_failed`, `chat.group_icon_update_failed`).
	//
	// | Code | Name | Description | Recommended Action |
	// |------|------|-------------|-------------------|
	// | 3007 | `retries_exhausted` | Maximum delivery attempts exceeded | Retry after delay |
	// | 4001 | `delivery_failed` | Request could not be delivered | Check phone status |
	ErrorCode WebhookErrorCode `json:"error_code"`

	// FailedAt When the failure was detected
	FailedAt time.Time `json:"failed_at"`
}

// ChatGroupIconUpdateFailedWebhook defines model for ChatGroupIconUpdateFailedWebhook.
type ChatGroupIconUpdateFailedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Error details for chat.group_icon_update_failed webhook events.
	// See [WebhookErrorCode](#/components/schemas/WebhookErrorCode) for the full error code reference.
	Data ChatGroupIconUpdateFailedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ChatGroupIconUpdatedEvent Payload for chat.group_icon_updated webhook events
type ChatGroupIconUpdatedEvent struct {
	// ChangedByHandle A handle representing a person (phone number or email address) as a participant in a chat
	ChangedByHandle *Handle `json:"changed_by_handle,omitempty"`

	// ChatId Chat identifier (UUID) of the group chat
	ChatId string `json:"chat_id"`

	// NewValue New icon URL (null if the icon was removed)
	NewValue *string `json:"new_value"`

	// OldValue Previous icon URL (null if no previous icon)
	OldValue *string `json:"old_value"`

	// UpdatedAt When the update occurred
	UpdatedAt time.Time `json:"updated_at"`
}

// ChatGroupIconUpdatedWebhook defines model for ChatGroupIconUpdatedWebhook.
type ChatGroupIconUpdatedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for chat.group_icon_updated webhook events
	Data ChatGroupIconUpdatedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ChatGroupNameUpdateFailedEvent Error details for chat.group_name_update_failed webhook events.
// See [WebhookErrorCode](#/components/schemas/WebhookErrorCode) for the full error code reference.
type ChatGroupNameUpdateFailedEvent struct {
	// ChatId Chat identifier (UUID) of the group chat
	ChatId string `json:"chat_id"`

	// ErrorCode Error codes that appear in webhook failure events (`message.failed`,
	// `chat.group_name_update_failed`, `chat.group_icon_update_failed`).
	//
	// | Code | Name | Description | Recommended Action |
	// |------|------|-------------|-------------------|
	// | 3007 | `retries_exhausted` | Maximum delivery attempts exceeded | Retry after delay |
	// | 4001 | `delivery_failed` | Request could not be delivered | Check phone status |
	ErrorCode WebhookErrorCode `json:"error_code"`

	// FailedAt When the failure was detected
	FailedAt time.Time `json:"failed_at"`
}

// ChatGroupNameUpdateFailedWebhook defines model for ChatGroupNameUpdateFailedWebhook.
type ChatGroupNameUpdateFailedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Error details for chat.group_name_update_failed webhook events.
	// See [WebhookErrorCode](#/components/schemas/WebhookErrorCode) for the full error code reference.
	Data ChatGroupNameUpdateFailedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ChatGroupNameUpdatedEvent Payload for chat.group_name_updated webhook events
type ChatGroupNameUpdatedEvent struct {
	// ChangedByHandle A handle representing a person (phone number or email address) as a participant in a chat
	ChangedByHandle *Handle `json:"changed_by_handle,omitempty"`

	// ChatId Chat identifier (UUID) of the group chat
	ChatId string `json:"chat_id"`

	// NewValue New group name (null if the name was removed)
	NewValue *string `json:"new_value"`

	// OldValue Previous group name (null if no previous name)
	OldValue *string `json:"old_value"`

	// UpdatedAt When the update occurred
	UpdatedAt time.Time `json:"updated_at"`
}

// ChatGroupNameUpdatedWebhook defines model for ChatGroupNameUpdatedWebhook.
type ChatGroupNameUpdatedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for chat.group_name_updated webhook events
	Data ChatGroupNameUpdatedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ChatHandle defines model for ChatHandle.
type ChatHandle struct {
	// Handle Phone number (E.164) or email address of the participant
	Handle string `json:"handle"`

	// Id Unique identifier for this handle
	Id openapi_types.UUID `json:"id"`

	// IsMe Whether this handle belongs to the sender (your phone number)
	IsMe *bool `json:"is_me,omitempty"`

	// JoinedAt When this participant joined the chat
	JoinedAt time.Time `json:"joined_at"`

	// LeftAt When they left (if applicable)
	LeftAt *time.Time `json:"left_at"`

	// Service Service type (iMessage, SMS, RCS, etc.)
	Service ChatHandleService `json:"service"`

	// Status Participant status
	Status *ChatHandleStatus `json:"status,omitempty"`
}

// ChatHandleService Service type (iMessage, SMS, RCS, etc.)
type ChatHandleService string

// ChatHandleStatus Participant status
type ChatHandleStatus string

// ChatInfo defines model for ChatInfo.
type ChatInfo struct {
	// Handles Chat participants
	Handles []struct {
		// Handle Phone number or email address of the participant
		Handle   *string             `json:"handle,omitempty"`
		Id       *openapi_types.UUID `json:"id,omitempty"`
		JoinedAt *time.Time          `json:"joined_at,omitempty"`
		Service  *string             `json:"service,omitempty"`
	} `json:"handles"`

	// Id Chat identifier
	Id openapi_types.UUID `json:"id"`

	// IsActive Whether the chat is active
	IsActive bool `json:"is_active"`

	// IsGroup Whether this is a group chat
	IsGroup bool `json:"is_group"`

	// Service Messaging service
	Service string `json:"service"`
}

// CreateChatRequest defines model for CreateChatRequest.
type CreateChatRequest struct {
	// From Sender phone number in E.164 format. Must be a phone number that the
	// authenticated partner has permission to send from.
	From string `json:"from"`

	// Message Message content container. Groups all message-related fields together,
	// separating the "what" (message content) from the "where" (routing fields like from/to).
	Message MessageContent `json:"message"`

	// To Array of recipient handles (phone numbers in E.164 format or email addresses).
	// For individual chats, provide one recipient. For group chats, provide multiple.
	To []string `json:"to"`
}

// CreateChatResult Response for creating a new chat with an initial message
type CreateChatResult struct {
	Chat struct {
		// DisplayName Display name of the chat or primary participant
		DisplayName *string `json:"display_name"`

		// Handles List of participants in the chat
		Handles []ChatHandle `json:"handles"`

		// Id Unique identifier for the created chat (UUID)
		Id openapi_types.UUID `json:"id"`

		// IsGroup Whether this is a group chat
		IsGroup bool `json:"is_group"`

		// Message A message that was sent (used in CreateChat and SendMessage responses)
		Message SentMessage `json:"message"`

		// Service Messaging service used
		Service string `json:"service"`
	} `json:"chat"`
}

// CreateWebhookSubscriptionRequest defines model for CreateWebhookSubscriptionRequest.
type CreateWebhookSubscriptionRequest struct {
	// SubscribedEvents List of event types to subscribe to
	SubscribedEvents []string `json:"subscribed_events"`

	// TargetUrl URL where webhook events will be sent. Must be HTTPS.
	TargetUrl string `json:"target_url"`
}

// DeleteMessageRequest defines model for DeleteMessageRequest.
type DeleteMessageRequest struct {
	// ChatId ID of the chat containing the message to delete
	ChatId openapi_types.UUID `json:"chat_id"`
}

// DeliveryStatus Current delivery status of a message
type DeliveryStatus string

// ErrorDetail defines model for ErrorDetail.
type ErrorDetail struct {
	// Code Linq API error code for programmatic error handling
	Code int `json:"code"`

	// Message Human-readable error message
	Message string `json:"message"`

	// Status HTTP status code (e.g., 400, 404, 500)
	Status int `json:"status"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error ErrorDetail `json:"error"`

	// Success Always false for error responses
	Success bool `json:"success"`

	// TraceId Unique trace ID for request tracing and debugging
	TraceId *string `json:"trace_id,omitempty"`
}

// GetMessagesResult defines model for GetMessagesResult.
type GetMessagesResult struct {
	// Messages List of messages
	Messages []Message `json:"messages"`

	// NextCursor Cursor for fetching the next page of results.
	// Null if there are no more results to fetch.
	// Pass this value as the `cursor` parameter in the next request.
	NextCursor *string `json:"next_cursor"`
}

// GetThreadResponse Response containing messages in a thread with pagination
type GetThreadResponse struct {
	// Messages Messages in the thread, ordered by the specified order parameter
	Messages []ThreadMessage `json:"messages"`

	// NextCursor Cursor for fetching the next page of results (null if no more results)
	NextCursor *string `json:"next_cursor"`
}

// Handle A handle representing a person (phone number or email address) as a participant in a chat
type Handle struct {
	// Handle Phone number (E.164 format) or email address
	Handle string `json:"handle"`

	// Id Unique identifier for this handle
	Id *openapi_types.UUID `json:"id,omitempty"`

	// IsMe Whether this handle belongs to your account (your phone number)
	IsMe bool `json:"is_me"`

	// JoinedAt When this participant joined the chat
	JoinedAt *time.Time `json:"joined_at,omitempty"`

	// LeftAt When this participant left the chat (if applicable)
	LeftAt *time.Time `json:"left_at"`

	// Service Service type (iMessage, SMS, RCS)
	Service *HandleService `json:"service,omitempty"`

	// Status Participant status in the chat
	Status *HandleStatus `json:"status,omitempty"`
}

// HandleService Service type (iMessage, SMS, RCS)
type HandleService string

// HandleStatus Participant status in the chat
type HandleStatus string

// ListChatsResult defines model for ListChatsResult.
type ListChatsResult struct {
	// Chats List of chats
	Chats []Chat `json:"chats"`

	// NextCursor Cursor for fetching the next page of results.
	// Null if there are no more results to fetch.
	// Pass this value as the `cursor` parameter in the next request.
	NextCursor *string `json:"next_cursor"`
}

// ListPhoneNumbersResult defines model for ListPhoneNumbersResult.
type ListPhoneNumbersResult struct {
	// PhoneNumbers List of phone numbers assigned to the partner
	PhoneNumbers []PhoneNumberInfo `json:"phone_numbers"`
}

// ListWebhookSubscriptionsResult defines model for ListWebhookSubscriptionsResult.
type ListWebhookSubscriptionsResult struct {
	// Subscriptions List of webhook subscriptions
	Subscriptions []WebhookSubscriptionResponse `json:"subscriptions"`
}

// MediaPart defines model for MediaPart.
type MediaPart struct {
	// AttachmentId Reference to a file pre-uploaded via `POST /v3/attachments` (optional).
	// The file is already stored, so sends using this ID skip the download step —
	// useful when sending the same file to many recipients.
	//
	// Either `url` or `attachment_id` must be provided, but not both.
	AttachmentId *openapi_types.UUID `json:"attachment_id,omitempty"`

	// IdempotencyKey Optional idempotency key for this specific message part.
	// Use this to prevent duplicate sends of the same part.
	IdempotencyKey *string `json:"idempotency_key,omitempty"`

	// Type Indicates this is a media attachment part
	Type MediaPartType `json:"type"`

	// Url Any publicly accessible HTTPS URL to the media file. The server downloads and
	// sends the file automatically — no pre-upload step required.
	//
	// **Note:** The file is downloaded on each send. If you send the same URL to
	// multiple recipients, consider using `attachment_id` instead to avoid redundant downloads.
	//
	// **Supported formats:**
	// - Images: .jpg, .jpeg, .png, .gif, .heic, .heif, .tif, .tiff, .bmp
	// - Videos: .mp4, .mov, .m4v, .mpeg, .mpg, .3gp
	// - Documents: .pdf, .txt, .rtf, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx, .pages, .numbers, .key, .epub, .zip, .html, .htm
	// - Contact & Calendar: .vcf, .ics
	//
	// **Note:** Audio files should use the dedicated `/v3/chats/{chatId}/voicememo` endpoint.
	//
	// Either `url` or `attachment_id` must be provided, but not both.
	Url *string `json:"url,omitempty"`
}

// MediaPartType Indicates this is a media attachment part
type MediaPartType string

// MediaPartResponse A media attachment part
type MediaPartResponse struct {
	// Filename Original filename
	Filename string `json:"filename"`

	// Id Unique attachment identifier
	Id openapi_types.UUID `json:"id"`

	// MimeType MIME type of the file
	MimeType string `json:"mime_type"`

	// Reactions Reactions on this message part
	Reactions *[]Reaction `json:"reactions"`

	// SizeBytes File size in bytes
	SizeBytes int `json:"size_bytes"`

	// Type Indicates this is a media attachment part
	Type MediaPartResponseType `json:"type"`

	// Url Presigned URL for downloading the attachment (expires in 1 hour).
	Url string `json:"url"`
}

// MediaPartResponseType Indicates this is a media attachment part
type MediaPartResponseType string

// Message defines model for Message.
type Message struct {
	// ChatId ID of the chat this message belongs to
	ChatId openapi_types.UUID `json:"chat_id"`

	// CreatedAt When the message was created
	CreatedAt time.Time `json:"created_at"`

	// DeliveredAt When the message was delivered
	DeliveredAt *time.Time `json:"delivered_at,omitempty"`

	// Effect iMessage effect applied to this message (screen or bubble effect)
	Effect *MessageEffect `json:"effect"`

	// From Phone number of the message sender
	From *string `json:"from,omitempty"`

	// Id Unique identifier for the message
	Id openapi_types.UUID `json:"id"`

	// IsDelivered Whether the message has been delivered
	IsDelivered bool `json:"is_delivered"`

	// IsFromMe Whether this message was sent by the authenticated user
	IsFromMe bool `json:"is_from_me"`

	// IsRead Whether the message has been read
	IsRead bool `json:"is_read"`

	// Parts Message parts in order (text and media)
	Parts *[]Message_Parts_Item `json:"parts,omitempty"`

	// ReadAt When the message was read
	ReadAt  *time.Time `json:"read_at,omitempty"`
	ReplyTo *ReplyTo   `json:"reply_to"`

	// SentAt When the message was sent
	SentAt *time.Time `json:"sent_at,omitempty"`

	// UpdatedAt When the message was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// Message_Parts_Item defines model for Message.parts.Item.
type Message_Parts_Item struct {
	union json.RawMessage
}

// MessageContent Message content container. Groups all message-related fields together,
// separating the "what" (message content) from the "where" (routing fields like from/to).
type MessageContent struct {
	// Effect iMessage effect applied to a message (screen or bubble effect)
	Effect *MessageEffect `json:"effect,omitempty"`

	// IdempotencyKey Optional idempotency key for this message.
	// Use this to prevent duplicate sends of the same message.
	IdempotencyKey *string `json:"idempotency_key,omitempty"`

	// Parts Array of message parts. Each part can be either text or media.
	// Parts are displayed in order. Text and media can be mixed.
	//
	// **Supported Media:**
	// - Images: .jpg, .jpeg, .png, .gif, .heic, .heif, .tif, .tiff, .bmp
	// - Videos: .mp4, .mov, .m4v, .mpeg, .mpg, .3gp
	// - Documents: .pdf, .txt, .rtf, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx, .pages, .numbers, .key, .epub, .zip, .html, .htm
	// - Contact & Calendar: .vcf, .ics
	//
	// **Audio Handling:**
	// - Audio files (voice memos) should use the dedicated `/v3/chats/{chatId}/voicememo` endpoint
	// - This ensures proper voice memo formatting and playback in iMessage
	//
	// **Validation Rule:** Consecutive text parts are not allowed. Text parts must
	// be separated by media parts. For example, [text, text] is invalid, but
	// [text, media, text] is valid.
	Parts []MessagePart `json:"parts"`

	// PreferredService Preferred messaging service to use for this message.
	// If not specified, uses default fallback chain: iMessage → RCS → SMS.
	// - iMessage: Enforces iMessage without fallback to RCS or SMS. Message fails if recipient doesn't support iMessage.
	// - RCS: Enforces RCS or SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
	// - SMS: Enforces SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
	PreferredService *MessageContentPreferredService `json:"preferred_service,omitempty"`

	// ReplyTo Indicates this message is a threaded reply to another message
	ReplyTo *ReplyTo `json:"reply_to,omitempty"`
}

// MessageContentPreferredService Preferred messaging service to use for this message.
// If not specified, uses default fallback chain: iMessage → RCS → SMS.
// - iMessage: Enforces iMessage without fallback to RCS or SMS. Message fails if recipient doesn't support iMessage.
// - RCS: Enforces RCS or SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
// - SMS: Enforces SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
type MessageContentPreferredService string

// MessageDeliveredEvent Payload for message.delivered webhook events
type MessageDeliveredEvent struct {
	// ChatId Chat identifier (UUID)
	ChatId *string `json:"chat_id,omitempty"`

	// DeliveredAt When the message was delivered to the recipient's device
	DeliveredAt time.Time `json:"delivered_at"`

	// MessageId Message identifier (UUID)
	MessageId *string `json:"message_id,omitempty"`
}

// MessageDeliveredWebhook defines model for MessageDeliveredWebhook.
type MessageDeliveredWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for message.delivered webhook events
	Data MessageDeliveredEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// MessageEffect iMessage effect applied to a message (screen or bubble effect)
type MessageEffect struct {
	// Name Name of the effect. Common values:
	// - Screen effects: confetti, fireworks, lasers, sparkles, celebration, hearts, love, balloons, happy_birthday, echo, spotlight
	// - Bubble effects: slam, loud, gentle, invisible
	Name *string `json:"name,omitempty"`

	// Type Type of effect
	Type *MessageEffectType `json:"type,omitempty"`
}

// MessageEffectType Type of effect
type MessageEffectType string

// MessageEffects Message effects for iMessage. Only one effect type can be applied per message.
// Screen effects play a full-screen animation. Bubble effects animate the message bubble.
type MessageEffects struct {
	// BubbleEffect Message bubble animation effect. Available bubble effects:
	// - slam: Message slams onto screen with impact
	// - loud: Message appears larger with emphasis
	// - gentle: Message fades in softly
	// - invisible: Invisible ink effect (revealed on tap)
	BubbleEffect *MessageEffectsBubbleEffect `json:"bubble_effect,omitempty"`

	// ScreenEffect Full-screen animation effect. Available screen effects:
	// - confetti: Colorful confetti falls from top of screen
	// - fireworks: Fireworks explode across the screen
	// - lasers: Laser beams scan across the screen
	// - sparkles: Sparkle/celebration effect
	// - celebration: Alias for sparkles (matches UI name)
	// - hearts: Floating hearts fill the screen
	// - love: Alias for hearts (matches UI name)
	// - balloons: Colorful balloons float up
	// - happy_birthday: Alias for balloons
	// - echo: Message text echoes/multiplies across screen
	// - spotlight: Spotlight illuminates the message
	ScreenEffect *MessageEffectsScreenEffect `json:"screen_effect,omitempty"`
}

// MessageEffectsBubbleEffect Message bubble animation effect. Available bubble effects:
// - slam: Message slams onto screen with impact
// - loud: Message appears larger with emphasis
// - gentle: Message fades in softly
// - invisible: Invisible ink effect (revealed on tap)
type MessageEffectsBubbleEffect string

// MessageEffectsScreenEffect Full-screen animation effect. Available screen effects:
// - confetti: Colorful confetti falls from top of screen
// - fireworks: Fireworks explode across the screen
// - lasers: Laser beams scan across the screen
// - sparkles: Sparkle/celebration effect
// - celebration: Alias for sparkles (matches UI name)
// - hearts: Floating hearts fill the screen
// - love: Alias for hearts (matches UI name)
// - balloons: Colorful balloons float up
// - happy_birthday: Alias for balloons
// - echo: Message text echoes/multiplies across screen
// - spotlight: Spotlight illuminates the message
type MessageEffectsScreenEffect string

// MessageFailedEvent Error details for message.failed webhook events.
// See [WebhookErrorCode](#/components/schemas/WebhookErrorCode) for the full error code reference.
type MessageFailedEvent struct {
	// ChatId Chat identifier (UUID)
	ChatId *string `json:"chat_id,omitempty"`

	// Code Error codes that appear in webhook failure events (`message.failed`,
	// `chat.group_name_update_failed`, `chat.group_icon_update_failed`).
	//
	// | Code | Name | Description | Recommended Action |
	// |------|------|-------------|-------------------|
	// | 3007 | `retries_exhausted` | Maximum delivery attempts exceeded | Retry after delay |
	// | 4001 | `delivery_failed` | Request could not be delivered | Check phone status |
	Code WebhookErrorCode `json:"code"`

	// FailedAt When the failure was detected
	FailedAt time.Time `json:"failed_at"`

	// MessageId Message identifier (UUID)
	MessageId *string `json:"message_id,omitempty"`

	// Reason Human-readable description of the failure
	Reason *string `json:"reason,omitempty"`
}

// MessageFailedWebhook defines model for MessageFailedWebhook.
type MessageFailedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Error details for message.failed webhook events.
	// See [WebhookErrorCode](#/components/schemas/WebhookErrorCode) for the full error code reference.
	Data MessageFailedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// MessagePart defines model for MessagePart.
type MessagePart struct {
	union json.RawMessage
}

// MessagePayload Message content nested within webhook events
type MessagePayload struct {
	// Effect iMessage effect applied to a message (screen or bubble animation)
	Effect *SchemasMessageEffect `json:"effect,omitempty"`

	// Id Message identifier
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Parts Message content parts (text and/or media)
	Parts *[]MessagePayload_Parts_Item `json:"parts,omitempty"`

	// ReplyTo Reference to the message this is replying to
	ReplyTo *struct {
		// MessageId The ID of the message being replied to
		MessageId *openapi_types.UUID `json:"message_id,omitempty"`

		// PartIndex Index of the message part being replied to (0-based)
		PartIndex *int32 `json:"part_index,omitempty"`
	} `json:"reply_to,omitempty"`
}

// MessagePayload_Parts_Item defines model for MessagePayload.parts.Item.
type MessagePayload_Parts_Item struct {
	union json.RawMessage
}

// MessageReadEvent Payload for message.read webhook events
type MessageReadEvent struct {
	// ChatId Chat identifier (UUID)
	ChatId *string `json:"chat_id,omitempty"`

	// MessageId Message identifier (UUID)
	MessageId *string `json:"message_id,omitempty"`

	// ReadAt When the message was read
	ReadAt time.Time `json:"read_at"`
}

// MessageReadWebhook defines model for MessageReadWebhook.
type MessageReadWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for message.read webhook events
	Data MessageReadEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// MessageReceivedEvent Payload for message.received webhook events
type MessageReceivedEvent struct {
	// ChatId Chat identifier
	ChatId *openapi_types.UUID `json:"chat_id,omitempty"`

	// From Phone number or email address of the message sender
	From *string `json:"from,omitempty"`

	// IsFromMe Whether the message was sent by us (always false for received events)
	IsFromMe *bool `json:"is_from_me,omitempty"`

	// Message Message content nested within webhook events
	Message *MessagePayload `json:"message,omitempty"`

	// ReceivedAt When the message was received
	ReceivedAt *time.Time `json:"received_at,omitempty"`

	// RecipientPhone Our phone number that received the message
	RecipientPhone *string `json:"recipient_phone,omitempty"`

	// Service Message service type
	Service *MessageReceivedEventService `json:"service,omitempty"`
}

// MessageReceivedEventService Message service type
type MessageReceivedEventService string

// MessageReceivedWebhook defines model for MessageReceivedWebhook.
type MessageReceivedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for message.received webhook events
	Data MessageReceivedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// MessageSentEvent Payload for message.sent webhook events
type MessageSentEvent struct {
	// ChatId Chat identifier
	ChatId *openapi_types.UUID `json:"chat_id,omitempty"`

	// From Phone number of the message sender (the phone number you sent from)
	From *string `json:"from,omitempty"`

	// IsFromMe Whether the message was sent by us (always true for sent events)
	IsFromMe *bool `json:"is_from_me,omitempty"`

	// Message Message content nested within webhook events
	Message *MessagePayload `json:"message,omitempty"`

	// Service Message service type
	Service *MessageSentEventService `json:"service,omitempty"`
}

// MessageSentEventService Message service type
type MessageSentEventService string

// MessageSentWebhook defines model for MessageSentWebhook.
type MessageSentWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for message.sent webhook events
	Data MessageSentEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ParticipantAddedEvent Payload for participant.added webhook events
type ParticipantAddedEvent struct {
	// AddedAt When the participant was added
	AddedAt *time.Time `json:"added_at,omitempty"`

	// ChatId Chat identifier (UUID) of the group chat
	ChatId *string `json:"chat_id,omitempty"`

	// Handle Handle (phone number or email address) of the added participant
	Handle string `json:"handle"`
}

// ParticipantAddedWebhook defines model for ParticipantAddedWebhook.
type ParticipantAddedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for participant.added webhook events
	Data ParticipantAddedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ParticipantRemovedEvent Payload for participant.removed webhook events
type ParticipantRemovedEvent struct {
	// ChatId Chat identifier (UUID) of the group chat
	ChatId *string `json:"chat_id,omitempty"`

	// Handle Handle (phone number or email address) of the removed participant
	Handle string `json:"handle"`

	// RemovedAt When the participant was removed
	RemovedAt *time.Time `json:"removed_at,omitempty"`
}

// ParticipantRemovedWebhook defines model for ParticipantRemovedWebhook.
type ParticipantRemovedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for participant.removed webhook events
	Data ParticipantRemovedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// PhoneCapabilities defines model for PhoneCapabilities.
type PhoneCapabilities struct {
	// Mms Whether MMS messaging is supported
	Mms bool `json:"mms"`

	// Sms Whether SMS messaging is supported
	Sms bool `json:"sms"`

	// Voice Whether voice calls are supported
	Voice bool `json:"voice"`
}

// PhoneNumberInfo defines model for PhoneNumberInfo.
type PhoneNumberInfo struct {
	Capabilities PhoneCapabilities `json:"capabilities"`

	// CountryCode ISO 3166-1 alpha-2 country code
	CountryCode string `json:"country_code"`

	// Id Unique identifier for the phone number
	Id openapi_types.UUID `json:"id"`

	// PhoneNumber Phone number in E.164 format
	PhoneNumber string `json:"phone_number"`

	// Type Type of phone number
	Type PhoneNumberInfoType `json:"type"`
}

// PhoneNumberInfoType Type of phone number
type PhoneNumberInfoType string

// Reaction defines model for Reaction.
type Reaction struct {
	// CustomEmoji Custom emoji if type is "custom", null otherwise
	CustomEmoji *string    `json:"custom_emoji"`
	Handle      ChatHandle `json:"handle"`

	// IsMe Whether this reaction is from the current user
	IsMe bool `json:"is_me"`

	// Type Type of reaction. Standard iMessage tapbacks are love, like, dislike, laugh, emphasize, question.
	// Custom emoji reactions have type "custom" with the actual emoji in the custom_emoji field.
	Type ReactionType `json:"type"`
}

// ReactionAddedEvent defines model for ReactionAddedEvent.
type ReactionAddedEvent = ReactionEventBase

// ReactionAddedWebhook defines model for ReactionAddedWebhook.
type ReactionAddedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for reaction.added webhook events
	Data ReactionAddedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ReactionEventBase defines model for ReactionEventBase.
type ReactionEventBase struct {
	// ChatId Chat identifier (UUID)
	ChatId *string `json:"chat_id,omitempty"`

	// CustomEmoji The actual emoji when reaction_type is "custom". Null for standard tapbacks.
	CustomEmoji *string `json:"custom_emoji"`

	// From Phone number or email address of the person who added/removed the reaction
	From *string `json:"from,omitempty"`

	// IsFromMe Whether this reaction was from the owner of the phone number (true) or from someone else (false)
	IsFromMe bool `json:"is_from_me"`

	// MessageId Message identifier (UUID) that the reaction was added to or removed from
	MessageId *string `json:"message_id,omitempty"`

	// PartIndex Index of the message part that was reacted to (0-based)
	PartIndex *int32 `json:"part_index,omitempty"`

	// ReactedAt When the reaction was added or removed
	ReactedAt *time.Time `json:"reacted_at,omitempty"`

	// ReactionType Type of reaction. Standard iMessage tapbacks are love, like, dislike, laugh, emphasize, question.
	// Custom emoji reactions have type "custom" with the actual emoji in the custom_emoji field.
	ReactionType ReactionType `json:"reaction_type"`

	// Service Message service type
	Service *ReactionEventBaseService `json:"service,omitempty"`
}

// ReactionEventBaseService Message service type
type ReactionEventBaseService string

// ReactionRemovedEvent defines model for ReactionRemovedEvent.
type ReactionRemovedEvent = ReactionEventBase

// ReactionRemovedWebhook defines model for ReactionRemovedWebhook.
type ReactionRemovedWebhook struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// Data Payload for reaction.removed webhook events
	Data ReactionRemovedEvent `json:"data"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// EventType The type of event
	EventType string `json:"event_type"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// ReactionType Type of reaction. Standard iMessage tapbacks are love, like, dislike, laugh, emphasize, question.
// Custom emoji reactions have type "custom" with the actual emoji in the custom_emoji field.
type ReactionType string

// RemoveParticipantRequest defines model for RemoveParticipantRequest.
type RemoveParticipantRequest struct {
	// Handle Phone number (E.164 format) or email address of the participant to remove
	Handle string `json:"handle"`
}

// ReplyTo Indicates this message is a threaded reply to another message
type ReplyTo struct {
	// MessageId The ID of the message to reply to
	MessageId openapi_types.UUID `json:"message_id"`

	// PartIndex The specific message part to reply to (0-based index).
	// Defaults to 0 (first part) if not provided.
	// Use this when replying to a specific part of a multipart message.
	PartIndex *int32 `json:"part_index,omitempty"`
}

// RequestUploadRequest defines model for RequestUploadRequest.
type RequestUploadRequest struct {
	// ContentType Supported MIME types for file attachments and media URLs.
	//
	// **Images:** image/jpeg, image/png, image/gif, image/heic, image/heif, image/tiff, image/bmp
	//
	// **Videos:** video/mp4, video/quicktime, video/mpeg, video/3gpp
	//
	// **Audio:** audio/mpeg, audio/mp4, audio/x-m4a, audio/x-caf, audio/wav, audio/aiff, audio/aac, audio/amr
	//
	// **Documents:** application/pdf, text/plain, text/vcard, text/rtf, text/csv, text/html, text/calendar, application/msword, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-powerpoint, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.apple.pages, application/vnd.apple.numbers, application/vnd.apple.keynote, application/epub+zip, application/zip
	//
	// **Unsupported:** WebP, SVG, FLAC, OGG, and executable files are explicitly rejected.
	ContentType SupportedContentType `json:"content_type"`

	// Filename Name of the file to upload
	Filename string `json:"filename"`

	// SizeBytes Size of the file in bytes (max 100MB)
	SizeBytes int64 `json:"size_bytes"`
}

// RequestUploadResult defines model for RequestUploadResult.
type RequestUploadResult struct {
	// AttachmentId Unique identifier for the attachment (for status checks via GET /v3/attachments/{id})
	AttachmentId openapi_types.UUID `json:"attachment_id"`

	// DownloadUrl Permanent CDN URL for the file. Does not expire. Use the `attachment_id`
	// to reference this file in media parts when sending messages.
	DownloadUrl string `json:"download_url"`

	// ExpiresAt When the upload URL expires (15 minutes from now)
	ExpiresAt time.Time `json:"expires_at"`

	// HttpMethod HTTP method to use for upload (always PUT)
	HttpMethod RequestUploadResultHttpMethod `json:"http_method"`

	// RequiredHeaders HTTP headers required for the upload request
	RequiredHeaders map[string]string `json:"required_headers"`

	// UploadUrl Presigned URL for uploading the file. PUT the raw binary file content to this URL
	// with the `required_headers`. Do not JSON-encode or multipart-wrap the body.
	// Expires after 15 minutes.
	UploadUrl string `json:"upload_url"`
}

// RequestUploadResultHttpMethod HTTP method to use for upload (always PUT)
type RequestUploadResultHttpMethod string

// SendMessageResponse Response for sending a message to a chat
type SendMessageResponse struct {
	// ChatId Unique identifier of the chat this message was sent to
	ChatId openapi_types.UUID `json:"chat_id"`

	// Message A message that was sent (used in CreateChat and SendMessage responses)
	Message SentMessage `json:"message"`
}

// SendMessageToChatRequest defines model for SendMessageToChatRequest.
type SendMessageToChatRequest struct {
	// Message Message content container. Groups all message-related fields together,
	// separating the "what" (message content) from the "where" (routing fields like from/to).
	Message MessageContent `json:"message"`
}

// SendReactionRequest defines model for SendReactionRequest.
type SendReactionRequest struct {
	// CustomEmoji Custom emoji string. Required when type is "custom".
	CustomEmoji *string `json:"custom_emoji,omitempty"`

	// Operation Whether to add or remove the reaction
	Operation SendReactionRequestOperation `json:"operation"`

	// PartIndex Optional index of the message part to react to.
	// If not provided, reacts to the entire message (part 0).
	PartIndex *int `json:"part_index,omitempty"`

	// Type Type of reaction. Standard iMessage tapbacks are love, like, dislike, laugh, emphasize, question.
	// Custom emoji reactions have type "custom" with the actual emoji in the custom_emoji field.
	Type ReactionType `json:"type"`
}

// SendReactionRequestOperation Whether to add or remove the reaction
type SendReactionRequestOperation string

// SendVoiceMemoResponse defines model for SendVoiceMemoResponse.
type SendVoiceMemoResponse struct {
	Chat    ChatInfo         `json:"chat"`
	Message VoiceMemoMessage `json:"message"`

	// Success Whether the voice memo was successfully queued
	Success bool `json:"success"`
}

// SendVoiceMemoToChatRequest Request to send a voice memo to a chat (chat_id provided in path)
type SendVoiceMemoToChatRequest struct {
	// From Sender phone number in E.164 format
	From string `json:"from"`

	// VoiceMemoUrl URL of the voice memo audio file. Must be a publicly accessible HTTPS URL.
	VoiceMemoUrl string `json:"voice_memo_url"`
}

// SendVoiceMemoToChatResult Response for sending a voice memo to a chat
type SendVoiceMemoToChatResult struct {
	VoiceMemo struct {
		Chat ChatInfo `json:"chat"`

		// CreatedAt When the voice memo was created
		CreatedAt time.Time `json:"created_at"`

		// From Sender phone number
		From string `json:"from"`

		// Id Message identifier
		Id openapi_types.UUID `json:"id"`

		// Status Current delivery status
		Status string `json:"status"`

		// To Recipient handles (phone numbers or email addresses)
		To        []string            `json:"to"`
		VoiceMemo VoiceMemoAttachment `json:"voice_memo"`
	} `json:"voice_memo"`
}

// SentMessage A message that was sent (used in CreateChat and SendMessage responses)
type SentMessage struct {
	// DeliveredAt When the message was delivered
	DeliveredAt *time.Time `json:"delivered_at"`

	// DeliveryStatus Current delivery status of a message
	DeliveryStatus DeliveryStatus `json:"delivery_status"`

	// Effect iMessage effect applied to this message (screen or bubble effect)
	Effect *MessageEffect `json:"effect"`

	// Id Message identifier (UUID)
	Id openapi_types.UUID `json:"id"`

	// IsRead Whether the message has been read
	IsRead bool `json:"is_read"`

	// Parts Message parts in order (text and media)
	Parts   []SentMessage_Parts_Item `json:"parts"`
	ReplyTo *ReplyTo                 `json:"reply_to"`

	// SentAt When the message was sent
	SentAt time.Time `json:"sent_at"`
}

// SentMessage_Parts_Item defines model for SentMessage.parts.Item.
type SentMessage_Parts_Item struct {
	union json.RawMessage
}

// SupportedContentType Supported MIME types for file attachments and media URLs.
//
// **Images:** image/jpeg, image/png, image/gif, image/heic, image/heif, image/tiff, image/bmp
//
// **Videos:** video/mp4, video/quicktime, video/mpeg, video/3gpp
//
// **Audio:** audio/mpeg, audio/mp4, audio/x-m4a, audio/x-caf, audio/wav, audio/aiff, audio/aac, audio/amr
//
// **Documents:** application/pdf, text/plain, text/vcard, text/rtf, text/csv, text/html, text/calendar, application/msword, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.ms-excel, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-powerpoint, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.apple.pages, application/vnd.apple.numbers, application/vnd.apple.keynote, application/epub+zip, application/zip
//
// **Unsupported:** WebP, SVG, FLAC, OGG, and executable files are explicitly rejected.
type SupportedContentType string

// TextPart defines model for TextPart.
type TextPart struct {
	// IdempotencyKey Optional idempotency key for this specific message part.
	// Use this to prevent duplicate sends of the same part.
	IdempotencyKey *string `json:"idempotency_key,omitempty"`

	// Type Indicates this is a text message part
	Type TextPartType `json:"type"`

	// Value The text content
	Value string `json:"value"`
}

// TextPartType Indicates this is a text message part
type TextPartType string

// TextPartResponse A text message part
type TextPartResponse struct {
	// Reactions Reactions on this message part
	Reactions *[]Reaction `json:"reactions"`

	// Type Indicates this is a text message part
	Type TextPartResponseType `json:"type"`

	// Value The text content
	Value string `json:"value"`
}

// TextPartResponseType Indicates this is a text message part
type TextPartResponseType string

// ThreadMessage A message within a thread (includes reply_to field)
type ThreadMessage struct {
	// DeliveredAt When the message was delivered
	DeliveredAt *time.Time `json:"delivered_at"`

	// DeliveryStatus Current delivery status of a message
	DeliveryStatus DeliveryStatus `json:"delivery_status"`

	// Effect iMessage effect applied to this message (screen or bubble effect)
	Effect *MessageEffect `json:"effect"`

	// Id Message identifier (UUID)
	Id openapi_types.UUID `json:"id"`

	// IsRead Whether the message has been read
	IsRead bool `json:"is_read"`

	// Parts Message parts in order (text and media)
	Parts []ThreadMessage_Parts_Item `json:"parts"`

	// ReplyTo Which message and part this is replying to (null for thread originator)
	ReplyTo *ReplyTo `json:"reply_to"`

	// SentAt When the message was sent
	SentAt time.Time `json:"sent_at"`
}

// ThreadMessage_Parts_Item defines model for ThreadMessage.parts.Item.
type ThreadMessage_Parts_Item struct {
	union json.RawMessage
}

// UpdateChatRequest defines model for UpdateChatRequest.
type UpdateChatRequest struct {
	// DisplayName New display name for the chat (group chats only)
	DisplayName *string `json:"display_name,omitempty"`

	// GroupChatIcon URL of an image to set as the group chat icon (group chats only)
	GroupChatIcon *string `json:"group_chat_icon,omitempty"`
}

// UpdateWebhookSubscriptionRequest defines model for UpdateWebhookSubscriptionRequest.
type UpdateWebhookSubscriptionRequest struct {
	// IsActive Activate or deactivate the subscription
	IsActive *bool `json:"is_active,omitempty"`

	// SubscribedEvents Updated list of event types to subscribe to
	SubscribedEvents *[]string `json:"subscribed_events,omitempty"`

	// TargetUrl New target URL for webhook events
	TargetUrl *string `json:"target_url,omitempty"`
}

// VoiceMemoAttachment defines model for VoiceMemoAttachment.
type VoiceMemoAttachment struct {
	// DurationMs Duration in milliseconds
	DurationMs *int `json:"duration_ms"`

	// Filename Original filename
	Filename string `json:"filename"`

	// Id Attachment identifier
	Id openapi_types.UUID `json:"id"`

	// MimeType Audio MIME type
	MimeType string `json:"mime_type"`

	// SizeBytes File size in bytes
	SizeBytes int `json:"size_bytes"`

	// Url CDN URL for downloading the voice memo
	Url string `json:"url"`
}

// VoiceMemoMessage defines model for VoiceMemoMessage.
type VoiceMemoMessage struct {
	// ChatId Chat identifier
	ChatId openapi_types.UUID `json:"chat_id"`

	// CreatedAt When the voice memo was created
	CreatedAt time.Time `json:"created_at"`

	// From Sender phone number
	From string `json:"from"`

	// Id Message identifier
	Id openapi_types.UUID `json:"id"`

	// Status Current delivery status
	Status string `json:"status"`

	// To Recipient handles (phone numbers or email addresses)
	To        []string            `json:"to"`
	VoiceMemo VoiceMemoAttachment `json:"voice_memo"`
}

// WebhookEnvelopeBase defines model for WebhookEnvelopeBase.
type WebhookEnvelopeBase struct {
	// ApiVersion API version for the webhook payload format
	ApiVersion string `json:"api_version"`

	// CreatedAt When the event was created
	CreatedAt time.Time `json:"created_at"`

	// EventId Unique identifier for this event (for deduplication)
	EventId openapi_types.UUID `json:"event_id"`

	// PartnerId Partner identifier. Present on all webhooks for cross-referencing.
	PartnerId string `json:"partner_id"`

	// TraceId Trace ID for debugging and correlation across systems.
	TraceId string `json:"trace_id"`
}

// WebhookErrorCode Error codes that appear in webhook failure events (`message.failed`,
// `chat.group_name_update_failed`, `chat.group_icon_update_failed`).
//
// | Code | Name | Description | Recommended Action |
// |------|------|-------------|-------------------|
// | 3007 | `retries_exhausted` | Maximum delivery attempts exceeded | Retry after delay |
// | 4001 | `delivery_failed` | Request could not be delivered | Check phone status |
type WebhookErrorCode int

// WebhookSubscriptionCreatedResponse Response returned when creating a webhook subscription. Includes the signing secret which is only shown once.
type WebhookSubscriptionCreatedResponse struct {
	// CreatedAt When the subscription was created
	CreatedAt time.Time `json:"created_at"`

	// Id Unique identifier for the webhook subscription
	Id string `json:"id"`

	// IsActive Whether this subscription is currently active
	IsActive bool `json:"is_active"`

	// SigningSecret Secret for verifying webhook signatures. Store this securely - it cannot be retrieved again.
	SigningSecret string `json:"signing_secret"`

	// SubscribedEvents List of event types this subscription receives
	SubscribedEvents []string `json:"subscribed_events"`

	// TargetUrl URL where webhook events will be sent
	TargetUrl string `json:"target_url"`

	// UpdatedAt When the subscription was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// WebhookSubscriptionResponse defines model for WebhookSubscriptionResponse.
type WebhookSubscriptionResponse struct {
	// CreatedAt When the subscription was created
	CreatedAt time.Time `json:"created_at"`

	// Id Unique identifier for the webhook subscription
	Id string `json:"id"`

	// IsActive Whether this subscription is currently active
	IsActive bool `json:"is_active"`

	// SubscribedEvents List of event types this subscription receives
	SubscribedEvents []string `json:"subscribed_events"`

	// TargetUrl URL where webhook events will be sent
	TargetUrl string `json:"target_url"`

	// UpdatedAt When the subscription was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// SchemasMediaPartResponse A media attachment part
type SchemasMediaPartResponse struct {
	// Filename Original filename
	Filename string `json:"filename"`

	// Id Unique attachment identifier
	Id openapi_types.UUID `json:"id"`

	// MimeType MIME type of the file
	MimeType string `json:"mime_type"`

	// SizeBytes File size in bytes
	SizeBytes int `json:"size_bytes"`

	// Type Indicates this is a media attachment part
	Type SchemasMediaPartResponseType `json:"type"`

	// Url Presigned URL for downloading the attachment (expires in 1 hour).
	Url string `json:"url"`
}

// SchemasMediaPartResponseType Indicates this is a media attachment part
type SchemasMediaPartResponseType string

// SchemasMessageEffect iMessage effect applied to a message (screen or bubble animation)
type SchemasMessageEffect struct {
	// Name Effect name (confetti, fireworks, slam, gentle, etc.)
	Name *string `json:"name,omitempty"`

	// Type Effect category
	Type *SchemasMessageEffectType `json:"type,omitempty"`
}

// SchemasMessageEffectType Effect category
type SchemasMessageEffectType string

// SchemasTextPartResponse A text message part
type SchemasTextPartResponse struct {
	// Type Indicates this is a text message part
	Type SchemasTextPartResponseType `json:"type"`

	// Value The text content
	Value string `json:"value"`
}

// SchemasTextPartResponseType Indicates this is a text message part
type SchemasTextPartResponseType string

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// Forbidden defines model for Forbidden.
type Forbidden = ErrorResponse

// InternalServerError defines model for InternalServerError.
type InternalServerError = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// Unauthorized defines model for Unauthorized.
type Unauthorized = ErrorResponse

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = ErrorResponse

// ListChatsParams defines parameters for ListChats.
type ListChatsParams struct {
	// From Phone number to filter chats by. Returns all chats made from this phone number.
	// Must be in E.164 format with the `+` sign URL-encoded as `%2B` (e.g., `%2B13343284472`).
	From string `form:"from" json:"from"`

	// Limit Maximum number of chats to return per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Pagination cursor from the previous response's `next_cursor` field.
	// Omit this parameter for the first page of results.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GetMessagesParams defines parameters for GetMessages.
type GetMessagesParams struct {
	// Cursor Pagination cursor from previous next_cursor response
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of messages to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetMessageThreadParams defines parameters for GetMessageThread.
type GetMessageThreadParams struct {
	// Cursor Pagination cursor from previous next_cursor response
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of messages to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Order Sort order for messages (asc = oldest first, desc = newest first)
	Order *GetMessageThreadParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// GetMessageThreadParamsOrder defines parameters for GetMessageThread.
type GetMessageThreadParamsOrder string

// RequestUploadJSONRequestBody defines body for RequestUpload for application/json ContentType.
type RequestUploadJSONRequestBody = RequestUploadRequest

// CreateChatJSONRequestBody defines body for CreateChat for application/json ContentType.
type CreateChatJSONRequestBody = CreateChatRequest

// UpdateChatJSONRequestBody defines body for UpdateChat for application/json ContentType.
type UpdateChatJSONRequestBody = UpdateChatRequest

// SendMessageToChatJSONRequestBody defines body for SendMessageToChat for application/json ContentType.
type SendMessageToChatJSONRequestBody = SendMessageToChatRequest

// RemoveParticipantJSONRequestBody defines body for RemoveParticipant for application/json ContentType.
type RemoveParticipantJSONRequestBody = RemoveParticipantRequest

// AddParticipantJSONRequestBody defines body for AddParticipant for application/json ContentType.
type AddParticipantJSONRequestBody = AddParticipantRequest

// SendVoiceMemoToChatJSONRequestBody defines body for SendVoiceMemoToChat for application/json ContentType.
type SendVoiceMemoToChatJSONRequestBody = SendVoiceMemoToChatRequest

// DeleteMessageJSONRequestBody defines body for DeleteMessage for application/json ContentType.
type DeleteMessageJSONRequestBody = DeleteMessageRequest

// SendReactionJSONRequestBody defines body for SendReaction for application/json ContentType.
type SendReactionJSONRequestBody = SendReactionRequest

// CreateWebhookSubscriptionJSONRequestBody defines body for CreateWebhookSubscription for application/json ContentType.
type CreateWebhookSubscriptionJSONRequestBody = CreateWebhookSubscriptionRequest

// UpdateWebhookSubscriptionJSONRequestBody defines body for UpdateWebhookSubscription for application/json ContentType.
type UpdateWebhookSubscriptionJSONRequestBody = UpdateWebhookSubscriptionRequest

// AsTextPartResponse returns the union data inside the Message_Parts_Item as a TextPartResponse
func (t Message_Parts_Item) AsTextPartResponse() (TextPartResponse, error) {
	var body TextPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextPartResponse overwrites any union data inside the Message_Parts_Item as the provided TextPartResponse
func (t *Message_Parts_Item) FromTextPartResponse(v TextPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextPartResponse performs a merge with any union data inside the Message_Parts_Item, using the provided TextPartResponse
func (t *Message_Parts_Item) MergeTextPartResponse(v TextPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMediaPartResponse returns the union data inside the Message_Parts_Item as a MediaPartResponse
func (t Message_Parts_Item) AsMediaPartResponse() (MediaPartResponse, error) {
	var body MediaPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMediaPartResponse overwrites any union data inside the Message_Parts_Item as the provided MediaPartResponse
func (t *Message_Parts_Item) FromMediaPartResponse(v MediaPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMediaPartResponse performs a merge with any union data inside the Message_Parts_Item, using the provided MediaPartResponse
func (t *Message_Parts_Item) MergeMediaPartResponse(v MediaPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Message_Parts_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Message_Parts_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTextPart returns the union data inside the MessagePart as a TextPart
func (t MessagePart) AsTextPart() (TextPart, error) {
	var body TextPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextPart overwrites any union data inside the MessagePart as the provided TextPart
func (t *MessagePart) FromTextPart(v TextPart) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextPart performs a merge with any union data inside the MessagePart, using the provided TextPart
func (t *MessagePart) MergeTextPart(v TextPart) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMediaPart returns the union data inside the MessagePart as a MediaPart
func (t MessagePart) AsMediaPart() (MediaPart, error) {
	var body MediaPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMediaPart overwrites any union data inside the MessagePart as the provided MediaPart
func (t *MessagePart) FromMediaPart(v MediaPart) error {
	v.Type = "media"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMediaPart performs a merge with any union data inside the MessagePart, using the provided MediaPart
func (t *MessagePart) MergeMediaPart(v MediaPart) error {
	v.Type = "media"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MessagePart) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MessagePart) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "media":
		return t.AsMediaPart()
	case "text":
		return t.AsTextPart()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MessagePart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MessagePart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSchemasTextPartResponse returns the union data inside the MessagePayload_Parts_Item as a SchemasTextPartResponse
func (t MessagePayload_Parts_Item) AsSchemasTextPartResponse() (SchemasTextPartResponse, error) {
	var body SchemasTextPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasTextPartResponse overwrites any union data inside the MessagePayload_Parts_Item as the provided SchemasTextPartResponse
func (t *MessagePayload_Parts_Item) FromSchemasTextPartResponse(v SchemasTextPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasTextPartResponse performs a merge with any union data inside the MessagePayload_Parts_Item, using the provided SchemasTextPartResponse
func (t *MessagePayload_Parts_Item) MergeSchemasTextPartResponse(v SchemasTextPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemasMediaPartResponse returns the union data inside the MessagePayload_Parts_Item as a SchemasMediaPartResponse
func (t MessagePayload_Parts_Item) AsSchemasMediaPartResponse() (SchemasMediaPartResponse, error) {
	var body SchemasMediaPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemasMediaPartResponse overwrites any union data inside the MessagePayload_Parts_Item as the provided SchemasMediaPartResponse
func (t *MessagePayload_Parts_Item) FromSchemasMediaPartResponse(v SchemasMediaPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemasMediaPartResponse performs a merge with any union data inside the MessagePayload_Parts_Item, using the provided SchemasMediaPartResponse
func (t *MessagePayload_Parts_Item) MergeSchemasMediaPartResponse(v SchemasMediaPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MessagePayload_Parts_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MessagePayload_Parts_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTextPartResponse returns the union data inside the SentMessage_Parts_Item as a TextPartResponse
func (t SentMessage_Parts_Item) AsTextPartResponse() (TextPartResponse, error) {
	var body TextPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextPartResponse overwrites any union data inside the SentMessage_Parts_Item as the provided TextPartResponse
func (t *SentMessage_Parts_Item) FromTextPartResponse(v TextPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextPartResponse performs a merge with any union data inside the SentMessage_Parts_Item, using the provided TextPartResponse
func (t *SentMessage_Parts_Item) MergeTextPartResponse(v TextPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMediaPartResponse returns the union data inside the SentMessage_Parts_Item as a MediaPartResponse
func (t SentMessage_Parts_Item) AsMediaPartResponse() (MediaPartResponse, error) {
	var body MediaPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMediaPartResponse overwrites any union data inside the SentMessage_Parts_Item as the provided MediaPartResponse
func (t *SentMessage_Parts_Item) FromMediaPartResponse(v MediaPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMediaPartResponse performs a merge with any union data inside the SentMessage_Parts_Item, using the provided MediaPartResponse
func (t *SentMessage_Parts_Item) MergeMediaPartResponse(v MediaPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SentMessage_Parts_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SentMessage_Parts_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTextPartResponse returns the union data inside the ThreadMessage_Parts_Item as a TextPartResponse
func (t ThreadMessage_Parts_Item) AsTextPartResponse() (TextPartResponse, error) {
	var body TextPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextPartResponse overwrites any union data inside the ThreadMessage_Parts_Item as the provided TextPartResponse
func (t *ThreadMessage_Parts_Item) FromTextPartResponse(v TextPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextPartResponse performs a merge with any union data inside the ThreadMessage_Parts_Item, using the provided TextPartResponse
func (t *ThreadMessage_Parts_Item) MergeTextPartResponse(v TextPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMediaPartResponse returns the union data inside the ThreadMessage_Parts_Item as a MediaPartResponse
func (t ThreadMessage_Parts_Item) AsMediaPartResponse() (MediaPartResponse, error) {
	var body MediaPartResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMediaPartResponse overwrites any union data inside the ThreadMessage_Parts_Item as the provided MediaPartResponse
func (t *ThreadMessage_Parts_Item) FromMediaPartResponse(v MediaPartResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMediaPartResponse performs a merge with any union data inside the ThreadMessage_Parts_Item, using the provided MediaPartResponse
func (t *ThreadMessage_Parts_Item) MergeMediaPartResponse(v MediaPartResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ThreadMessage_Parts_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ThreadMessage_Parts_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// RequestUploadWithBody request with any body
	RequestUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestUpload(ctx context.Context, body RequestUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttachment request
	GetAttachment(ctx context.Context, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListChats request
	ListChats(ctx context.Context, params *ListChatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateChatWithBody request with any body
	CreateChatWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateChat(ctx context.Context, body CreateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChat request
	GetChat(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChatWithBody request with any body
	UpdateChatWithBody(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateChat(ctx context.Context, chatId openapi_types.UUID, body UpdateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMessages request
	GetMessages(ctx context.Context, chatId openapi_types.UUID, params *GetMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendMessageToChatWithBody request with any body
	SendMessageToChatWithBody(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendMessageToChat(ctx context.Context, chatId openapi_types.UUID, body SendMessageToChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveParticipantWithBody request with any body
	RemoveParticipantWithBody(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveParticipant(ctx context.Context, chatId openapi_types.UUID, body RemoveParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddParticipantWithBody request with any body
	AddParticipantWithBody(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddParticipant(ctx context.Context, chatId openapi_types.UUID, body AddParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkChatAsRead request
	MarkChatAsRead(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShareContactWithChat request
	ShareContactWithChat(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopTyping request
	StopTyping(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartTyping request
	StartTyping(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendVoiceMemoToChatWithBody request with any body
	SendVoiceMemoToChatWithBody(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendVoiceMemoToChat(ctx context.Context, chatId openapi_types.UUID, body SendVoiceMemoToChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMessageWithBody request with any body
	DeleteMessageWithBody(ctx context.Context, messageId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteMessage(ctx context.Context, messageId openapi_types.UUID, body DeleteMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMessage request
	GetMessage(ctx context.Context, messageId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendReactionWithBody request with any body
	SendReactionWithBody(ctx context.Context, messageId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendReaction(ctx context.Context, messageId openapi_types.UUID, body SendReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMessageThread request
	GetMessageThread(ctx context.Context, messageId openapi_types.UUID, params *GetMessageThreadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPhoneNumbers request
	ListPhoneNumbers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWebhookSubscriptions request
	ListWebhookSubscriptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWebhookSubscriptionWithBody request with any body
	CreateWebhookSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWebhookSubscription(ctx context.Context, body CreateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhookSubscription request
	DeleteWebhookSubscription(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhookSubscription request
	GetWebhookSubscription(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWebhookSubscriptionWithBody request with any body
	UpdateWebhookSubscriptionWithBody(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWebhookSubscription(ctx context.Context, subscriptionId string, body UpdateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) RequestUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestUploadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestUpload(ctx context.Context, body RequestUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestUploadRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttachment(ctx context.Context, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentRequest(c.Server, attachmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListChats(ctx context.Context, params *ListChatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListChatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateChatWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateChatRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateChat(ctx context.Context, body CreateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateChatRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChat(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChatRequest(c.Server, chatId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChatWithBody(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChatRequestWithBody(c.Server, chatId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChat(ctx context.Context, chatId openapi_types.UUID, body UpdateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChatRequest(c.Server, chatId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMessages(ctx context.Context, chatId openapi_types.UUID, params *GetMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMessagesRequest(c.Server, chatId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendMessageToChatWithBody(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendMessageToChatRequestWithBody(c.Server, chatId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendMessageToChat(ctx context.Context, chatId openapi_types.UUID, body SendMessageToChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendMessageToChatRequest(c.Server, chatId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveParticipantWithBody(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveParticipantRequestWithBody(c.Server, chatId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveParticipant(ctx context.Context, chatId openapi_types.UUID, body RemoveParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveParticipantRequest(c.Server, chatId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddParticipantWithBody(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddParticipantRequestWithBody(c.Server, chatId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddParticipant(ctx context.Context, chatId openapi_types.UUID, body AddParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddParticipantRequest(c.Server, chatId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkChatAsRead(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkChatAsReadRequest(c.Server, chatId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareContactWithChat(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareContactWithChatRequest(c.Server, chatId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopTyping(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopTypingRequest(c.Server, chatId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartTyping(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartTypingRequest(c.Server, chatId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendVoiceMemoToChatWithBody(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendVoiceMemoToChatRequestWithBody(c.Server, chatId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendVoiceMemoToChat(ctx context.Context, chatId openapi_types.UUID, body SendVoiceMemoToChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendVoiceMemoToChatRequest(c.Server, chatId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMessageWithBody(ctx context.Context, messageId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMessageRequestWithBody(c.Server, messageId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMessage(ctx context.Context, messageId openapi_types.UUID, body DeleteMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMessageRequest(c.Server, messageId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMessage(ctx context.Context, messageId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMessageRequest(c.Server, messageId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendReactionWithBody(ctx context.Context, messageId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendReactionRequestWithBody(c.Server, messageId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendReaction(ctx context.Context, messageId openapi_types.UUID, body SendReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendReactionRequest(c.Server, messageId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMessageThread(ctx context.Context, messageId openapi_types.UUID, params *GetMessageThreadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMessageThreadRequest(c.Server, messageId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPhoneNumbers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPhoneNumbersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWebhookSubscriptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebhookSubscriptionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhookSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookSubscriptionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhookSubscription(ctx context.Context, body CreateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookSubscriptionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhookSubscription(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookSubscriptionRequest(c.Server, subscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhookSubscription(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookSubscriptionRequest(c.Server, subscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhookSubscriptionWithBody(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookSubscriptionRequestWithBody(c.Server, subscriptionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhookSubscription(ctx context.Context, subscriptionId string, body UpdateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookSubscriptionRequest(c.Server, subscriptionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewRequestUploadRequest calls the generic RequestUpload builder with application/json body
func NewRequestUploadRequest(server string, body RequestUploadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestUploadRequestWithBody(server, "application/json", bodyReader)
}

// NewRequestUploadRequestWithBody generates requests for RequestUpload with any type of body
func NewRequestUploadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/attachments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAttachmentRequest generates requests for GetAttachment
func NewGetAttachmentRequest(server string, attachmentId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attachmentId", runtime.ParamLocationPath, attachmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/attachments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListChatsRequest generates requests for ListChats
func NewListChatsRequest(server string, params *ListChatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/chats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateChatRequest calls the generic CreateChat builder with application/json body
func NewCreateChatRequest(server string, body CreateChatJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateChatRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateChatRequestWithBody generates requests for CreateChat with any type of body
func NewCreateChatRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/chats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChatRequest generates requests for GetChat
func NewGetChatRequest(server string, chatId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chatId", runtime.ParamLocationPath, chatId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/chats/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateChatRequest calls the generic UpdateChat builder with application/json body
func NewUpdateChatRequest(server string, chatId openapi_types.UUID, body UpdateChatJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChatRequestWithBody(server, chatId, "application/json", bodyReader)
}

// NewUpdateChatRequestWithBody generates requests for UpdateChat with any type of body
func NewUpdateChatRequestWithBody(server string, chatId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chatId", runtime.ParamLocationPath, chatId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/chats/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMessagesRequest generates requests for GetMessages
func NewGetMessagesRequest(server string, chatId openapi_types.UUID, params *GetMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chatId", runtime.ParamLocationPath, chatId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/chats/%s/messages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendMessageToChatRequest calls the generic SendMessageToChat builder with application/json body
func NewSendMessageToChatRequest(server string, chatId openapi_types.UUID, body SendMessageToChatJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendMessageToChatRequestWithBody(server, chatId, "application/json", bodyReader)
}

// NewSendMessageToChatRequestWithBody generates requests for SendMessageToChat with any type of body
func NewSendMessageToChatRequestWithBody(server string, chatId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chatId", runtime.ParamLocationPath, chatId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/chats/%s/messages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveParticipantRequest calls the generic RemoveParticipant builder with application/json body
func NewRemoveParticipantRequest(server string, chatId openapi_types.UUID, body RemoveParticipantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveParticipantRequestWithBody(server, chatId, "application/json", bodyReader)
}

// NewRemoveParticipantRequestWithBody generates requests for RemoveParticipant with any type of body
func NewRemoveParticipantRequestWithBody(server string, chatId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chatId", runtime.ParamLocationPath, chatId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/chats/%s/participants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddParticipantRequest calls the generic AddParticipant builder with application/json body
func NewAddParticipantRequest(server string, chatId openapi_types.UUID, body AddParticipantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddParticipantRequestWithBody(server, chatId, "application/json", bodyReader)
}

// NewAddParticipantRequestWithBody generates requests for AddParticipant with any type of body
func NewAddParticipantRequestWithBody(server string, chatId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chatId", runtime.ParamLocationPath, chatId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/chats/%s/participants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarkChatAsReadRequest generates requests for MarkChatAsRead
func NewMarkChatAsReadRequest(server string, chatId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chatId", runtime.ParamLocationPath, chatId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/chats/%s/read", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShareContactWithChatRequest generates requests for ShareContactWithChat
func NewShareContactWithChatRequest(server string, chatId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chatId", runtime.ParamLocationPath, chatId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/chats/%s/share_contact_card", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopTypingRequest generates requests for StopTyping
func NewStopTypingRequest(server string, chatId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chatId", runtime.ParamLocationPath, chatId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/chats/%s/typing", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartTypingRequest generates requests for StartTyping
func NewStartTypingRequest(server string, chatId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chatId", runtime.ParamLocationPath, chatId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/chats/%s/typing", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendVoiceMemoToChatRequest calls the generic SendVoiceMemoToChat builder with application/json body
func NewSendVoiceMemoToChatRequest(server string, chatId openapi_types.UUID, body SendVoiceMemoToChatJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendVoiceMemoToChatRequestWithBody(server, chatId, "application/json", bodyReader)
}

// NewSendVoiceMemoToChatRequestWithBody generates requests for SendVoiceMemoToChat with any type of body
func NewSendVoiceMemoToChatRequestWithBody(server string, chatId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chatId", runtime.ParamLocationPath, chatId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/chats/%s/voicememo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMessageRequest calls the generic DeleteMessage builder with application/json body
func NewDeleteMessageRequest(server string, messageId openapi_types.UUID, body DeleteMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteMessageRequestWithBody(server, messageId, "application/json", bodyReader)
}

// NewDeleteMessageRequestWithBody generates requests for DeleteMessage with any type of body
func NewDeleteMessageRequestWithBody(server string, messageId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "messageId", runtime.ParamLocationPath, messageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/messages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMessageRequest generates requests for GetMessage
func NewGetMessageRequest(server string, messageId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "messageId", runtime.ParamLocationPath, messageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/messages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendReactionRequest calls the generic SendReaction builder with application/json body
func NewSendReactionRequest(server string, messageId openapi_types.UUID, body SendReactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendReactionRequestWithBody(server, messageId, "application/json", bodyReader)
}

// NewSendReactionRequestWithBody generates requests for SendReaction with any type of body
func NewSendReactionRequestWithBody(server string, messageId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "messageId", runtime.ParamLocationPath, messageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/messages/%s/reactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMessageThreadRequest generates requests for GetMessageThread
func NewGetMessageThreadRequest(server string, messageId openapi_types.UUID, params *GetMessageThreadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "messageId", runtime.ParamLocationPath, messageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/messages/%s/thread", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPhoneNumbersRequest generates requests for ListPhoneNumbers
func NewListPhoneNumbersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/phonenumbers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWebhookSubscriptionsRequest generates requests for ListWebhookSubscriptions
func NewListWebhookSubscriptionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/webhook-subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWebhookSubscriptionRequest calls the generic CreateWebhookSubscription builder with application/json body
func NewCreateWebhookSubscriptionRequest(server string, body CreateWebhookSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWebhookSubscriptionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWebhookSubscriptionRequestWithBody generates requests for CreateWebhookSubscription with any type of body
func NewCreateWebhookSubscriptionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/webhook-subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWebhookSubscriptionRequest generates requests for DeleteWebhookSubscription
func NewDeleteWebhookSubscriptionRequest(server string, subscriptionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/webhook-subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhookSubscriptionRequest generates requests for GetWebhookSubscription
func NewGetWebhookSubscriptionRequest(server string, subscriptionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/webhook-subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWebhookSubscriptionRequest calls the generic UpdateWebhookSubscription builder with application/json body
func NewUpdateWebhookSubscriptionRequest(server string, subscriptionId string, body UpdateWebhookSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWebhookSubscriptionRequestWithBody(server, subscriptionId, "application/json", bodyReader)
}

// NewUpdateWebhookSubscriptionRequestWithBody generates requests for UpdateWebhookSubscription with any type of body
func NewUpdateWebhookSubscriptionRequestWithBody(server string, subscriptionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/webhook-subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// RequestUploadWithBodyWithResponse request with any body
	RequestUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestUploadResponse, error)

	RequestUploadWithResponse(ctx context.Context, body RequestUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestUploadResponse, error)

	// GetAttachmentWithResponse request
	GetAttachmentWithResponse(ctx context.Context, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAttachmentResponse, error)

	// ListChatsWithResponse request
	ListChatsWithResponse(ctx context.Context, params *ListChatsParams, reqEditors ...RequestEditorFn) (*ListChatsResponse, error)

	// CreateChatWithBodyWithResponse request with any body
	CreateChatWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateChatResponse, error)

	CreateChatWithResponse(ctx context.Context, body CreateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateChatResponse, error)

	// GetChatWithResponse request
	GetChatWithResponse(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetChatResponse, error)

	// UpdateChatWithBodyWithResponse request with any body
	UpdateChatWithBodyWithResponse(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChatResponse, error)

	UpdateChatWithResponse(ctx context.Context, chatId openapi_types.UUID, body UpdateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChatResponse, error)

	// GetMessagesWithResponse request
	GetMessagesWithResponse(ctx context.Context, chatId openapi_types.UUID, params *GetMessagesParams, reqEditors ...RequestEditorFn) (*GetMessagesResponse, error)

	// SendMessageToChatWithBodyWithResponse request with any body
	SendMessageToChatWithBodyWithResponse(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendMessageToChatResponse, error)

	SendMessageToChatWithResponse(ctx context.Context, chatId openapi_types.UUID, body SendMessageToChatJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMessageToChatResponse, error)

	// RemoveParticipantWithBodyWithResponse request with any body
	RemoveParticipantWithBodyWithResponse(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveParticipantResponse, error)

	RemoveParticipantWithResponse(ctx context.Context, chatId openapi_types.UUID, body RemoveParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveParticipantResponse, error)

	// AddParticipantWithBodyWithResponse request with any body
	AddParticipantWithBodyWithResponse(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddParticipantResponse, error)

	AddParticipantWithResponse(ctx context.Context, chatId openapi_types.UUID, body AddParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*AddParticipantResponse, error)

	// MarkChatAsReadWithResponse request
	MarkChatAsReadWithResponse(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*MarkChatAsReadResponse, error)

	// ShareContactWithChatWithResponse request
	ShareContactWithChatWithResponse(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ShareContactWithChatResponse, error)

	// StopTypingWithResponse request
	StopTypingWithResponse(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*StopTypingResponse, error)

	// StartTypingWithResponse request
	StartTypingWithResponse(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*StartTypingResponse, error)

	// SendVoiceMemoToChatWithBodyWithResponse request with any body
	SendVoiceMemoToChatWithBodyWithResponse(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendVoiceMemoToChatResponse, error)

	SendVoiceMemoToChatWithResponse(ctx context.Context, chatId openapi_types.UUID, body SendVoiceMemoToChatJSONRequestBody, reqEditors ...RequestEditorFn) (*SendVoiceMemoToChatResponse, error)

	// DeleteMessageWithBodyWithResponse request with any body
	DeleteMessageWithBodyWithResponse(ctx context.Context, messageId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteMessageResponse, error)

	DeleteMessageWithResponse(ctx context.Context, messageId openapi_types.UUID, body DeleteMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteMessageResponse, error)

	// GetMessageWithResponse request
	GetMessageWithResponse(ctx context.Context, messageId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetMessageResponse, error)

	// SendReactionWithBodyWithResponse request with any body
	SendReactionWithBodyWithResponse(ctx context.Context, messageId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendReactionResponse, error)

	SendReactionWithResponse(ctx context.Context, messageId openapi_types.UUID, body SendReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SendReactionResponse, error)

	// GetMessageThreadWithResponse request
	GetMessageThreadWithResponse(ctx context.Context, messageId openapi_types.UUID, params *GetMessageThreadParams, reqEditors ...RequestEditorFn) (*GetMessageThreadResponse, error)

	// ListPhoneNumbersWithResponse request
	ListPhoneNumbersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPhoneNumbersResponse, error)

	// ListWebhookSubscriptionsWithResponse request
	ListWebhookSubscriptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWebhookSubscriptionsResponse, error)

	// CreateWebhookSubscriptionWithBodyWithResponse request with any body
	CreateWebhookSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookSubscriptionResponse, error)

	CreateWebhookSubscriptionWithResponse(ctx context.Context, body CreateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookSubscriptionResponse, error)

	// DeleteWebhookSubscriptionWithResponse request
	DeleteWebhookSubscriptionWithResponse(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*DeleteWebhookSubscriptionResponse, error)

	// GetWebhookSubscriptionWithResponse request
	GetWebhookSubscriptionWithResponse(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*GetWebhookSubscriptionResponse, error)

	// UpdateWebhookSubscriptionWithBodyWithResponse request with any body
	UpdateWebhookSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookSubscriptionResponse, error)

	UpdateWebhookSubscriptionWithResponse(ctx context.Context, subscriptionId string, body UpdateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookSubscriptionResponse, error)
}

type RequestUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestUploadResult
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RequestUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Attachment
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListChatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListChatsResult
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListChatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListChatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateChatResult
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Chat
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Chat
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetMessagesResult
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendMessageToChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SendMessageResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SendMessageToChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendMessageToChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		Message *string `json:"message,omitempty"`
		Status  *string `json:"status,omitempty"`
		TraceId *string `json:"trace_id,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RemoveParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		Message *string `json:"message,omitempty"`
		Status  *string `json:"status,omitempty"`
		TraceId *string `json:"trace_id,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AddParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkChatAsReadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r MarkChatAsReadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkChatAsReadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShareContactWithChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShareContactWithChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShareContactWithChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopTypingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r StopTypingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopTypingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartTypingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r StartTypingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartTypingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendVoiceMemoToChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SendVoiceMemoToChatResult
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON413      *ErrorResponse
	JSON422      *UnprocessableEntity
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SendVoiceMemoToChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendVoiceMemoToChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Message
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendReactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reaction
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SendReactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendReactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMessageThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetThreadResponse
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMessageThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMessageThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPhoneNumbersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPhoneNumbersResult
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListPhoneNumbersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPhoneNumbersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWebhookSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListWebhookSubscriptionsResult
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListWebhookSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebhookSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWebhookSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WebhookSubscriptionCreatedResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateWebhookSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWebhookSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookSubscriptionResponse
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetWebhookSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWebhookSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookSubscriptionResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateWebhookSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWebhookSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// RequestUploadWithBodyWithResponse request with arbitrary body returning *RequestUploadResponse
func (c *ClientWithResponses) RequestUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestUploadResponse, error) {
	rsp, err := c.RequestUploadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestUploadResponse(rsp)
}

func (c *ClientWithResponses) RequestUploadWithResponse(ctx context.Context, body RequestUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestUploadResponse, error) {
	rsp, err := c.RequestUpload(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestUploadResponse(rsp)
}

// GetAttachmentWithResponse request returning *GetAttachmentResponse
func (c *ClientWithResponses) GetAttachmentWithResponse(ctx context.Context, attachmentId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAttachmentResponse, error) {
	rsp, err := c.GetAttachment(ctx, attachmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentResponse(rsp)
}

// ListChatsWithResponse request returning *ListChatsResponse
func (c *ClientWithResponses) ListChatsWithResponse(ctx context.Context, params *ListChatsParams, reqEditors ...RequestEditorFn) (*ListChatsResponse, error) {
	rsp, err := c.ListChats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListChatsResponse(rsp)
}

// CreateChatWithBodyWithResponse request with arbitrary body returning *CreateChatResponse
func (c *ClientWithResponses) CreateChatWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateChatResponse, error) {
	rsp, err := c.CreateChatWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateChatResponse(rsp)
}

func (c *ClientWithResponses) CreateChatWithResponse(ctx context.Context, body CreateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateChatResponse, error) {
	rsp, err := c.CreateChat(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateChatResponse(rsp)
}

// GetChatWithResponse request returning *GetChatResponse
func (c *ClientWithResponses) GetChatWithResponse(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetChatResponse, error) {
	rsp, err := c.GetChat(ctx, chatId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChatResponse(rsp)
}

// UpdateChatWithBodyWithResponse request with arbitrary body returning *UpdateChatResponse
func (c *ClientWithResponses) UpdateChatWithBodyWithResponse(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChatResponse, error) {
	rsp, err := c.UpdateChatWithBody(ctx, chatId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChatResponse(rsp)
}

func (c *ClientWithResponses) UpdateChatWithResponse(ctx context.Context, chatId openapi_types.UUID, body UpdateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChatResponse, error) {
	rsp, err := c.UpdateChat(ctx, chatId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateChatResponse(rsp)
}

// GetMessagesWithResponse request returning *GetMessagesResponse
func (c *ClientWithResponses) GetMessagesWithResponse(ctx context.Context, chatId openapi_types.UUID, params *GetMessagesParams, reqEditors ...RequestEditorFn) (*GetMessagesResponse, error) {
	rsp, err := c.GetMessages(ctx, chatId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMessagesResponse(rsp)
}

// SendMessageToChatWithBodyWithResponse request with arbitrary body returning *SendMessageToChatResponse
func (c *ClientWithResponses) SendMessageToChatWithBodyWithResponse(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendMessageToChatResponse, error) {
	rsp, err := c.SendMessageToChatWithBody(ctx, chatId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendMessageToChatResponse(rsp)
}

func (c *ClientWithResponses) SendMessageToChatWithResponse(ctx context.Context, chatId openapi_types.UUID, body SendMessageToChatJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMessageToChatResponse, error) {
	rsp, err := c.SendMessageToChat(ctx, chatId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendMessageToChatResponse(rsp)
}

// RemoveParticipantWithBodyWithResponse request with arbitrary body returning *RemoveParticipantResponse
func (c *ClientWithResponses) RemoveParticipantWithBodyWithResponse(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveParticipantResponse, error) {
	rsp, err := c.RemoveParticipantWithBody(ctx, chatId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveParticipantResponse(rsp)
}

func (c *ClientWithResponses) RemoveParticipantWithResponse(ctx context.Context, chatId openapi_types.UUID, body RemoveParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveParticipantResponse, error) {
	rsp, err := c.RemoveParticipant(ctx, chatId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveParticipantResponse(rsp)
}

// AddParticipantWithBodyWithResponse request with arbitrary body returning *AddParticipantResponse
func (c *ClientWithResponses) AddParticipantWithBodyWithResponse(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddParticipantResponse, error) {
	rsp, err := c.AddParticipantWithBody(ctx, chatId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddParticipantResponse(rsp)
}

func (c *ClientWithResponses) AddParticipantWithResponse(ctx context.Context, chatId openapi_types.UUID, body AddParticipantJSONRequestBody, reqEditors ...RequestEditorFn) (*AddParticipantResponse, error) {
	rsp, err := c.AddParticipant(ctx, chatId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddParticipantResponse(rsp)
}

// MarkChatAsReadWithResponse request returning *MarkChatAsReadResponse
func (c *ClientWithResponses) MarkChatAsReadWithResponse(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*MarkChatAsReadResponse, error) {
	rsp, err := c.MarkChatAsRead(ctx, chatId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkChatAsReadResponse(rsp)
}

// ShareContactWithChatWithResponse request returning *ShareContactWithChatResponse
func (c *ClientWithResponses) ShareContactWithChatWithResponse(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ShareContactWithChatResponse, error) {
	rsp, err := c.ShareContactWithChat(ctx, chatId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareContactWithChatResponse(rsp)
}

// StopTypingWithResponse request returning *StopTypingResponse
func (c *ClientWithResponses) StopTypingWithResponse(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*StopTypingResponse, error) {
	rsp, err := c.StopTyping(ctx, chatId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopTypingResponse(rsp)
}

// StartTypingWithResponse request returning *StartTypingResponse
func (c *ClientWithResponses) StartTypingWithResponse(ctx context.Context, chatId openapi_types.UUID, reqEditors ...RequestEditorFn) (*StartTypingResponse, error) {
	rsp, err := c.StartTyping(ctx, chatId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartTypingResponse(rsp)
}

// SendVoiceMemoToChatWithBodyWithResponse request with arbitrary body returning *SendVoiceMemoToChatResponse
func (c *ClientWithResponses) SendVoiceMemoToChatWithBodyWithResponse(ctx context.Context, chatId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendVoiceMemoToChatResponse, error) {
	rsp, err := c.SendVoiceMemoToChatWithBody(ctx, chatId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendVoiceMemoToChatResponse(rsp)
}

func (c *ClientWithResponses) SendVoiceMemoToChatWithResponse(ctx context.Context, chatId openapi_types.UUID, body SendVoiceMemoToChatJSONRequestBody, reqEditors ...RequestEditorFn) (*SendVoiceMemoToChatResponse, error) {
	rsp, err := c.SendVoiceMemoToChat(ctx, chatId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendVoiceMemoToChatResponse(rsp)
}

// DeleteMessageWithBodyWithResponse request with arbitrary body returning *DeleteMessageResponse
func (c *ClientWithResponses) DeleteMessageWithBodyWithResponse(ctx context.Context, messageId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteMessageResponse, error) {
	rsp, err := c.DeleteMessageWithBody(ctx, messageId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMessageResponse(rsp)
}

func (c *ClientWithResponses) DeleteMessageWithResponse(ctx context.Context, messageId openapi_types.UUID, body DeleteMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteMessageResponse, error) {
	rsp, err := c.DeleteMessage(ctx, messageId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMessageResponse(rsp)
}

// GetMessageWithResponse request returning *GetMessageResponse
func (c *ClientWithResponses) GetMessageWithResponse(ctx context.Context, messageId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetMessageResponse, error) {
	rsp, err := c.GetMessage(ctx, messageId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMessageResponse(rsp)
}

// SendReactionWithBodyWithResponse request with arbitrary body returning *SendReactionResponse
func (c *ClientWithResponses) SendReactionWithBodyWithResponse(ctx context.Context, messageId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendReactionResponse, error) {
	rsp, err := c.SendReactionWithBody(ctx, messageId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendReactionResponse(rsp)
}

func (c *ClientWithResponses) SendReactionWithResponse(ctx context.Context, messageId openapi_types.UUID, body SendReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SendReactionResponse, error) {
	rsp, err := c.SendReaction(ctx, messageId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendReactionResponse(rsp)
}

// GetMessageThreadWithResponse request returning *GetMessageThreadResponse
func (c *ClientWithResponses) GetMessageThreadWithResponse(ctx context.Context, messageId openapi_types.UUID, params *GetMessageThreadParams, reqEditors ...RequestEditorFn) (*GetMessageThreadResponse, error) {
	rsp, err := c.GetMessageThread(ctx, messageId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMessageThreadResponse(rsp)
}

// ListPhoneNumbersWithResponse request returning *ListPhoneNumbersResponse
func (c *ClientWithResponses) ListPhoneNumbersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPhoneNumbersResponse, error) {
	rsp, err := c.ListPhoneNumbers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPhoneNumbersResponse(rsp)
}

// ListWebhookSubscriptionsWithResponse request returning *ListWebhookSubscriptionsResponse
func (c *ClientWithResponses) ListWebhookSubscriptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWebhookSubscriptionsResponse, error) {
	rsp, err := c.ListWebhookSubscriptions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebhookSubscriptionsResponse(rsp)
}

// CreateWebhookSubscriptionWithBodyWithResponse request with arbitrary body returning *CreateWebhookSubscriptionResponse
func (c *ClientWithResponses) CreateWebhookSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookSubscriptionResponse, error) {
	rsp, err := c.CreateWebhookSubscriptionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) CreateWebhookSubscriptionWithResponse(ctx context.Context, body CreateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookSubscriptionResponse, error) {
	rsp, err := c.CreateWebhookSubscription(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookSubscriptionResponse(rsp)
}

// DeleteWebhookSubscriptionWithResponse request returning *DeleteWebhookSubscriptionResponse
func (c *ClientWithResponses) DeleteWebhookSubscriptionWithResponse(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*DeleteWebhookSubscriptionResponse, error) {
	rsp, err := c.DeleteWebhookSubscription(ctx, subscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookSubscriptionResponse(rsp)
}

// GetWebhookSubscriptionWithResponse request returning *GetWebhookSubscriptionResponse
func (c *ClientWithResponses) GetWebhookSubscriptionWithResponse(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*GetWebhookSubscriptionResponse, error) {
	rsp, err := c.GetWebhookSubscription(ctx, subscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookSubscriptionResponse(rsp)
}

// UpdateWebhookSubscriptionWithBodyWithResponse request with arbitrary body returning *UpdateWebhookSubscriptionResponse
func (c *ClientWithResponses) UpdateWebhookSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookSubscriptionResponse, error) {
	rsp, err := c.UpdateWebhookSubscriptionWithBody(ctx, subscriptionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) UpdateWebhookSubscriptionWithResponse(ctx context.Context, subscriptionId string, body UpdateWebhookSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookSubscriptionResponse, error) {
	rsp, err := c.UpdateWebhookSubscription(ctx, subscriptionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookSubscriptionResponse(rsp)
}

// ParseRequestUploadResponse parses an HTTP response from a RequestUploadWithResponse call
func ParseRequestUploadResponse(rsp *http.Response) (*RequestUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestUploadResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAttachmentResponse parses an HTTP response from a GetAttachmentWithResponse call
func ParseGetAttachmentResponse(rsp *http.Response) (*GetAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Attachment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListChatsResponse parses an HTTP response from a ListChatsWithResponse call
func ParseListChatsResponse(rsp *http.Response) (*ListChatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListChatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListChatsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateChatResponse parses an HTTP response from a CreateChatWithResponse call
func ParseCreateChatResponse(rsp *http.Response) (*CreateChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateChatResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetChatResponse parses an HTTP response from a GetChatWithResponse call
func ParseGetChatResponse(rsp *http.Response) (*GetChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Chat
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateChatResponse parses an HTTP response from a UpdateChatWithResponse call
func ParseUpdateChatResponse(rsp *http.Response) (*UpdateChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Chat
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMessagesResponse parses an HTTP response from a GetMessagesWithResponse call
func ParseGetMessagesResponse(rsp *http.Response) (*GetMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetMessagesResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSendMessageToChatResponse parses an HTTP response from a SendMessageToChatWithResponse call
func ParseSendMessageToChatResponse(rsp *http.Response) (*SendMessageToChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendMessageToChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SendMessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveParticipantResponse parses an HTTP response from a RemoveParticipantWithResponse call
func ParseRemoveParticipantResponse(rsp *http.Response) (*RemoveParticipantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *string `json:"status,omitempty"`
			TraceId *string `json:"trace_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddParticipantResponse parses an HTTP response from a AddParticipantWithResponse call
func ParseAddParticipantResponse(rsp *http.Response) (*AddParticipantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Status  *string `json:"status,omitempty"`
			TraceId *string `json:"trace_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMarkChatAsReadResponse parses an HTTP response from a MarkChatAsReadWithResponse call
func ParseMarkChatAsReadResponse(rsp *http.Response) (*MarkChatAsReadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkChatAsReadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShareContactWithChatResponse parses an HTTP response from a ShareContactWithChatWithResponse call
func ParseShareContactWithChatResponse(rsp *http.Response) (*ShareContactWithChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShareContactWithChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStopTypingResponse parses an HTTP response from a StopTypingWithResponse call
func ParseStopTypingResponse(rsp *http.Response) (*StopTypingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopTypingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartTypingResponse parses an HTTP response from a StartTypingWithResponse call
func ParseStartTypingResponse(rsp *http.Response) (*StartTypingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartTypingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSendVoiceMemoToChatResponse parses an HTTP response from a SendVoiceMemoToChatWithResponse call
func ParseSendVoiceMemoToChatResponse(rsp *http.Response) (*SendVoiceMemoToChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendVoiceMemoToChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SendVoiceMemoToChatResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteMessageResponse parses an HTTP response from a DeleteMessageWithResponse call
func ParseDeleteMessageResponse(rsp *http.Response) (*DeleteMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMessageResponse parses an HTTP response from a GetMessageWithResponse call
func ParseGetMessageResponse(rsp *http.Response) (*GetMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSendReactionResponse parses an HTTP response from a SendReactionWithResponse call
func ParseSendReactionResponse(rsp *http.Response) (*SendReactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendReactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMessageThreadResponse parses an HTTP response from a GetMessageThreadWithResponse call
func ParseGetMessageThreadResponse(rsp *http.Response) (*GetMessageThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMessageThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetThreadResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPhoneNumbersResponse parses an HTTP response from a ListPhoneNumbersWithResponse call
func ParseListPhoneNumbersResponse(rsp *http.Response) (*ListPhoneNumbersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPhoneNumbersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPhoneNumbersResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListWebhookSubscriptionsResponse parses an HTTP response from a ListWebhookSubscriptionsWithResponse call
func ParseListWebhookSubscriptionsResponse(rsp *http.Response) (*ListWebhookSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWebhookSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListWebhookSubscriptionsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateWebhookSubscriptionResponse parses an HTTP response from a CreateWebhookSubscriptionWithResponse call
func ParseCreateWebhookSubscriptionResponse(rsp *http.Response) (*CreateWebhookSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWebhookSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WebhookSubscriptionCreatedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookSubscriptionResponse parses an HTTP response from a DeleteWebhookSubscriptionWithResponse call
func ParseDeleteWebhookSubscriptionResponse(rsp *http.Response) (*DeleteWebhookSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWebhookSubscriptionResponse parses an HTTP response from a GetWebhookSubscriptionWithResponse call
func ParseGetWebhookSubscriptionResponse(rsp *http.Response) (*GetWebhookSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookSubscriptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateWebhookSubscriptionResponse parses an HTTP response from a UpdateWebhookSubscriptionWithResponse call
func ParseUpdateWebhookSubscriptionResponse(rsp *http.Response) (*UpdateWebhookSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWebhookSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookSubscriptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
