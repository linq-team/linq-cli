/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * HTTP method to use for upload (always PUT)
 */
export const HttpMethod = {
  Put: "PUT",
} as const;
/**
 * HTTP method to use for upload (always PUT)
 */
export type HttpMethod = ClosedEnum<typeof HttpMethod>;

export type RequestUploadResult = {
  /**
   * Unique identifier for the attachment (for status checks via GET /v3/attachments/{id})
   */
  attachmentId: string;
  /**
   * Presigned URL for uploading the file. PUT the raw binary file content to this URL
   *
   * @remarks
   * with the `required_headers`. Do not JSON-encode or multipart-wrap the body.
   * Expires after 15 minutes.
   */
  uploadUrl: string;
  /**
   * Permanent CDN URL for the file. Does not expire. Use the `attachment_id`
   *
   * @remarks
   * to reference this file in media parts when sending messages.
   */
  downloadUrl: string;
  /**
   * HTTP method to use for upload (always PUT)
   */
  httpMethod: HttpMethod;
  /**
   * When the upload URL expires (15 minutes from now)
   */
  expiresAt: Date;
  /**
   * HTTP headers required for the upload request
   */
  requiredHeaders: { [k: string]: string };
};

/** @internal */
export const HttpMethod$inboundSchema: z.ZodMiniEnum<typeof HttpMethod> = z
  .enum(HttpMethod);

/** @internal */
export const RequestUploadResult$inboundSchema: z.ZodMiniType<
  RequestUploadResult,
  unknown
> = z.pipe(
  z.object({
    attachment_id: types.string(),
    upload_url: types.string(),
    download_url: types.string(),
    http_method: HttpMethod$inboundSchema,
    expires_at: types.date(),
    required_headers: z.record(z.string(), types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "attachment_id": "attachmentId",
      "upload_url": "uploadUrl",
      "download_url": "downloadUrl",
      "http_method": "httpMethod",
      "expires_at": "expiresAt",
      "required_headers": "requiredHeaders",
    });
  }),
);

export function requestUploadResultFromJSON(
  jsonString: string,
): SafeParseResult<RequestUploadResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestUploadResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestUploadResult' from JSON`,
  );
}
