/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";
import {
  MessageEventV2,
  MessageEventV2$inboundSchema,
  MessageEventV2$Outbound,
  MessageEventV2$outboundSchema,
} from "./message-event-v2.js";
import {
  WebhookEventType,
  WebhookEventType$inboundSchema,
  WebhookEventType$outboundSchema,
} from "./webhook-event-type.js";

/**
 * Complete webhook payload for message.received events (2026-02-03 format)
 */
export type MessageReceivedWebhookV2 = {
  /**
   * API version for the webhook payload format
   */
  apiVersion: string;
  /**
   * Date-based webhook payload version.
   *
   * @remarks
   * Determined by the `?version=` query parameter in your webhook subscription URL.
   * If no version parameter is specified, defaults based on subscription creation date.
   */
  webhookVersion: string;
  /**
   * Valid webhook event types that can be subscribed to
   */
  eventType: WebhookEventType;
  /**
   * Unique identifier for this event (for deduplication)
   */
  eventId: string;
  /**
   * When the event was created
   */
  createdAt: Date;
  /**
   * Trace ID for debugging and correlation across systems.
   */
  traceId: string;
  /**
   * Partner identifier. Present on all webhooks for cross-referencing.
   */
  partnerId: string;
  /**
   * Unified payload for message webhooks when using `webhook_version: "2026-02-03"`.
   *
   * @remarks
   *
   * This schema is used for message.sent, message.received, message.delivered, and message.read
   * events when the subscription URL includes `?version=2026-02-03`.
   *
   * Key differences from V1 (2025-01-01):
   * - `direction`: "inbound" or "outbound" instead of `is_from_me` boolean
   * - `sender_handle`: Full handle object for the sender
   * - `chat`: Nested object with `id`, `is_group`, and `owner_handle`
   * - Message fields (`id`, `parts`, `effect`, etc.) are at the top level, not nested in `message`
   *
   * Timestamps indicate the message state:
   * - `message.sent`: sent_at set, delivered_at=null, read_at=null
   * - `message.received`: sent_at set, delivered_at=null, read_at=null
   * - `message.delivered`: sent_at set, delivered_at set, read_at=null
   * - `message.read`: sent_at set, delivered_at set, read_at set
   */
  data: MessageEventV2;
};

/** @internal */
export const MessageReceivedWebhookV2$inboundSchema: z.ZodMiniType<
  MessageReceivedWebhookV2,
  unknown
> = z.pipe(
  z.object({
    api_version: types.string(),
    webhook_version: types.string(),
    event_type: WebhookEventType$inboundSchema,
    event_id: types.string(),
    created_at: types.date(),
    trace_id: types.string(),
    partner_id: types.string(),
    data: MessageEventV2$inboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      "api_version": "apiVersion",
      "webhook_version": "webhookVersion",
      "event_type": "eventType",
      "event_id": "eventId",
      "created_at": "createdAt",
      "trace_id": "traceId",
      "partner_id": "partnerId",
    });
  }),
);
/** @internal */
export type MessageReceivedWebhookV2$Outbound = {
  api_version: string;
  webhook_version: string;
  event_type: string;
  event_id: string;
  created_at: string;
  trace_id: string;
  partner_id: string;
  data: MessageEventV2$Outbound;
};

/** @internal */
export const MessageReceivedWebhookV2$outboundSchema: z.ZodMiniType<
  MessageReceivedWebhookV2$Outbound,
  MessageReceivedWebhookV2
> = z.pipe(
  z.object({
    apiVersion: z.string(),
    webhookVersion: z.string(),
    eventType: WebhookEventType$outboundSchema,
    eventId: z.string(),
    createdAt: z.pipe(z.date(), z.transform(v => v.toISOString())),
    traceId: z.string(),
    partnerId: z.string(),
    data: MessageEventV2$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      apiVersion: "api_version",
      webhookVersion: "webhook_version",
      eventType: "event_type",
      eventId: "event_id",
      createdAt: "created_at",
      traceId: "trace_id",
      partnerId: "partner_id",
    });
  }),
);

export function messageReceivedWebhookV2ToJSON(
  messageReceivedWebhookV2: MessageReceivedWebhookV2,
): string {
  return JSON.stringify(
    MessageReceivedWebhookV2$outboundSchema.parse(messageReceivedWebhookV2),
  );
}
export function messageReceivedWebhookV2FromJSON(
  jsonString: string,
): SafeParseResult<MessageReceivedWebhookV2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageReceivedWebhookV2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageReceivedWebhookV2' from JSON`,
  );
}
