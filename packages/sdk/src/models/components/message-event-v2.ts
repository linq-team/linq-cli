/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";
import {
  ChatHandle,
  ChatHandle$inboundSchema,
  ChatHandle$Outbound,
  ChatHandle$outboundSchema,
} from "./chat-handle.js";
import {
  SchemasMediaPartResponse,
  SchemasMediaPartResponse$inboundSchema,
  SchemasMediaPartResponse$Outbound,
  SchemasMediaPartResponse$outboundSchema,
} from "./schemas-media-part-response.js";
import {
  SchemasTextPartResponse,
  SchemasTextPartResponse$inboundSchema,
  SchemasTextPartResponse$Outbound,
  SchemasTextPartResponse$outboundSchema,
} from "./schemas-text-part-response.js";

/**
 * Service type (iMessage, SMS, RCS, etc.)
 */
export const OwnerHandleService = {
  IMessage: "iMessage",
  Sms: "SMS",
  Rcs: "RCS",
} as const;
/**
 * Service type (iMessage, SMS, RCS, etc.)
 */
export type OwnerHandleService = ClosedEnum<typeof OwnerHandleService>;

/**
 * Participant status
 */
export const MessageEventV2Status = {
  Active: "active",
  Left: "left",
  Removed: "removed",
} as const;
/**
 * Participant status
 */
export type MessageEventV2Status = ClosedEnum<typeof MessageEventV2Status>;

/**
 * Your phone number's handle. Always has is_me=true.
 */
export type OwnerHandle = {
  /**
   * Unique identifier for this handle
   */
  id: string;
  /**
   * Phone number (E.164) or email address of the participant
   */
  handle: string;
  /**
   * Service type (iMessage, SMS, RCS, etc.)
   */
  service: OwnerHandleService;
  /**
   * Participant status
   */
  status?: MessageEventV2Status | null | undefined;
  /**
   * When this participant joined the chat
   */
  joinedAt: Date;
  /**
   * When they left (if applicable)
   */
  leftAt?: Date | null | undefined;
  /**
   * Whether this handle belongs to the sender (your phone number)
   */
  isMe?: boolean | null | undefined;
};

/**
 * Chat information
 */
export type MessageEventV2Chat = {
  /**
   * Chat identifier
   */
  id: string;
  /**
   * Whether this is a group chat
   */
  isGroup?: boolean | null | undefined;
  /**
   * Your phone number's handle. Always has is_me=true.
   */
  ownerHandle?: OwnerHandle | null | undefined;
};

/**
 * Message direction - "outbound" if sent by you, "inbound" if received
 */
export const Direction = {
  Inbound: "inbound",
  Outbound: "outbound",
} as const;
/**
 * Message direction - "outbound" if sent by you, "inbound" if received
 */
export type Direction = ClosedEnum<typeof Direction>;

export type MessageEventV2Part =
  | SchemasTextPartResponse
  | SchemasMediaPartResponse;

/**
 * Reference to the message this is replying to (for threaded replies)
 */
export type MessageEventV2ReplyTo = {
  /**
   * ID of the message being replied to
   */
  messageId?: string | undefined;
  /**
   * Index of the part being replied to
   */
  partIndex?: number | undefined;
};

/**
 * Effect category
 */
export const MessageEventV2Type = {
  Screen: "screen",
  Bubble: "bubble",
} as const;
/**
 * Effect category
 */
export type MessageEventV2Type = ClosedEnum<typeof MessageEventV2Type>;

/**
 * iMessage effect applied to the message (bubble or screen animation). Null if no effect.
 */
export type MessageEventV2Effect = {
  /**
   * Effect category
   */
  type?: MessageEventV2Type | undefined;
  /**
   * Effect name (confetti, fireworks, slam, gentle, etc.)
   */
  name?: string | undefined;
};

/**
 * The service used to send/receive the message
 */
export const MessageEventV2Service = {
  IMessage: "iMessage",
  Sms: "SMS",
  Rcs: "RCS",
} as const;
/**
 * The service used to send/receive the message
 */
export type MessageEventV2Service = ClosedEnum<typeof MessageEventV2Service>;

/**
 * The service that was requested when sending. Null for inbound messages.
 */
export const MessageEventV2PreferredService = {
  IMessage: "iMessage",
  Sms: "SMS",
  Rcs: "RCS",
  Auto: "auto",
} as const;
/**
 * The service that was requested when sending. Null for inbound messages.
 */
export type MessageEventV2PreferredService = ClosedEnum<
  typeof MessageEventV2PreferredService
>;

/**
 * Unified payload for message webhooks when using `webhook_version: "2026-02-03"`.
 *
 * @remarks
 *
 * This schema is used for message.sent, message.received, message.delivered, and message.read
 * events when the subscription URL includes `?version=2026-02-03`.
 *
 * Key differences from V1 (2025-01-01):
 * - `direction`: "inbound" or "outbound" instead of `is_from_me` boolean
 * - `sender_handle`: Full handle object for the sender
 * - `chat`: Nested object with `id`, `is_group`, and `owner_handle`
 * - Message fields (`id`, `parts`, `effect`, etc.) are at the top level, not nested in `message`
 *
 * Timestamps indicate the message state:
 * - `message.sent`: sent_at set, delivered_at=null, read_at=null
 * - `message.received`: sent_at set, delivered_at=null, read_at=null
 * - `message.delivered`: sent_at set, delivered_at set, read_at=null
 * - `message.read`: sent_at set, delivered_at set, read_at set
 */
export type MessageEventV2 = {
  /**
   * Chat information
   */
  chat: MessageEventV2Chat;
  /**
   * Message identifier
   */
  id: string;
  /**
   * Idempotency key for deduplication of outbound messages.
   */
  idempotencyKey?: string | null | undefined;
  /**
   * Message direction - "outbound" if sent by you, "inbound" if received
   */
  direction: Direction;
  /**
   * The handle that sent this message
   */
  senderHandle: ChatHandle;
  /**
   * Message parts (text and/or media)
   */
  parts: Array<SchemasTextPartResponse | SchemasMediaPartResponse>;
  /**
   * When the message was sent. Null if not yet sent.
   */
  sentAt?: Date | null | undefined;
  /**
   * When the message was delivered. Null if not yet delivered.
   */
  deliveredAt?: Date | null | undefined;
  /**
   * When the message was read. Null if not yet read.
   */
  readAt?: Date | null | undefined;
  /**
   * Reference to the message this is replying to (for threaded replies)
   */
  replyTo?: MessageEventV2ReplyTo | null | undefined;
  /**
   * iMessage effect applied to the message (bubble or screen animation). Null if no effect.
   */
  effect?: MessageEventV2Effect | null | undefined;
  /**
   * The service used to send/receive the message
   */
  service: MessageEventV2Service;
  /**
   * The service that was requested when sending. Null for inbound messages.
   */
  preferredService?: MessageEventV2PreferredService | null | undefined;
};

/** @internal */
export const OwnerHandleService$inboundSchema: z.ZodMiniEnum<
  typeof OwnerHandleService
> = z.enum(OwnerHandleService);
/** @internal */
export const OwnerHandleService$outboundSchema: z.ZodMiniEnum<
  typeof OwnerHandleService
> = OwnerHandleService$inboundSchema;

/** @internal */
export const MessageEventV2Status$inboundSchema: z.ZodMiniEnum<
  typeof MessageEventV2Status
> = z.enum(MessageEventV2Status);
/** @internal */
export const MessageEventV2Status$outboundSchema: z.ZodMiniEnum<
  typeof MessageEventV2Status
> = MessageEventV2Status$inboundSchema;

/** @internal */
export const OwnerHandle$inboundSchema: z.ZodMiniType<OwnerHandle, unknown> = z
  .pipe(
    z.object({
      id: types.string(),
      handle: types.string(),
      service: OwnerHandleService$inboundSchema,
      status: z.nullable(
        z._default(MessageEventV2Status$inboundSchema, "active"),
      ),
      joined_at: types.date(),
      left_at: z.optional(z.nullable(types.date())),
      is_me: z.optional(z.nullable(types.boolean())),
    }),
    z.transform((v) => {
      return remap$(v, {
        "joined_at": "joinedAt",
        "left_at": "leftAt",
        "is_me": "isMe",
      });
    }),
  );
/** @internal */
export type OwnerHandle$Outbound = {
  id: string;
  handle: string;
  service: string;
  status: string | null;
  joined_at: string;
  left_at?: string | null | undefined;
  is_me?: boolean | null | undefined;
};

/** @internal */
export const OwnerHandle$outboundSchema: z.ZodMiniType<
  OwnerHandle$Outbound,
  OwnerHandle
> = z.pipe(
  z.object({
    id: z.string(),
    handle: z.string(),
    service: OwnerHandleService$outboundSchema,
    status: z.nullable(
      z._default(MessageEventV2Status$outboundSchema, "active"),
    ),
    joinedAt: z.pipe(z.date(), z.transform(v => v.toISOString())),
    leftAt: z.optional(
      z.nullable(z.pipe(z.date(), z.transform(v => v.toISOString()))),
    ),
    isMe: z.optional(z.nullable(z.boolean())),
  }),
  z.transform((v) => {
    return remap$(v, {
      joinedAt: "joined_at",
      leftAt: "left_at",
      isMe: "is_me",
    });
  }),
);

export function ownerHandleToJSON(ownerHandle: OwnerHandle): string {
  return JSON.stringify(OwnerHandle$outboundSchema.parse(ownerHandle));
}
export function ownerHandleFromJSON(
  jsonString: string,
): SafeParseResult<OwnerHandle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OwnerHandle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OwnerHandle' from JSON`,
  );
}

/** @internal */
export const MessageEventV2Chat$inboundSchema: z.ZodMiniType<
  MessageEventV2Chat,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    is_group: z.optional(z.nullable(types.boolean())),
    owner_handle: z.optional(
      z.nullable(z.lazy(() => OwnerHandle$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_group": "isGroup",
      "owner_handle": "ownerHandle",
    });
  }),
);
/** @internal */
export type MessageEventV2Chat$Outbound = {
  id: string;
  is_group?: boolean | null | undefined;
  owner_handle?: OwnerHandle$Outbound | null | undefined;
};

/** @internal */
export const MessageEventV2Chat$outboundSchema: z.ZodMiniType<
  MessageEventV2Chat$Outbound,
  MessageEventV2Chat
> = z.pipe(
  z.object({
    id: z.string(),
    isGroup: z.optional(z.nullable(z.boolean())),
    ownerHandle: z.optional(
      z.nullable(z.lazy(() => OwnerHandle$outboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      isGroup: "is_group",
      ownerHandle: "owner_handle",
    });
  }),
);

export function messageEventV2ChatToJSON(
  messageEventV2Chat: MessageEventV2Chat,
): string {
  return JSON.stringify(
    MessageEventV2Chat$outboundSchema.parse(messageEventV2Chat),
  );
}
export function messageEventV2ChatFromJSON(
  jsonString: string,
): SafeParseResult<MessageEventV2Chat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageEventV2Chat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageEventV2Chat' from JSON`,
  );
}

/** @internal */
export const Direction$inboundSchema: z.ZodMiniEnum<typeof Direction> = z.enum(
  Direction,
);
/** @internal */
export const Direction$outboundSchema: z.ZodMiniEnum<typeof Direction> =
  Direction$inboundSchema;

/** @internal */
export const MessageEventV2Part$inboundSchema: z.ZodMiniType<
  MessageEventV2Part,
  unknown
> = z.union([
  SchemasTextPartResponse$inboundSchema,
  SchemasMediaPartResponse$inboundSchema,
]);
/** @internal */
export type MessageEventV2Part$Outbound =
  | SchemasTextPartResponse$Outbound
  | SchemasMediaPartResponse$Outbound;

/** @internal */
export const MessageEventV2Part$outboundSchema: z.ZodMiniType<
  MessageEventV2Part$Outbound,
  MessageEventV2Part
> = z.union([
  SchemasTextPartResponse$outboundSchema,
  SchemasMediaPartResponse$outboundSchema,
]);

export function messageEventV2PartToJSON(
  messageEventV2Part: MessageEventV2Part,
): string {
  return JSON.stringify(
    MessageEventV2Part$outboundSchema.parse(messageEventV2Part),
  );
}
export function messageEventV2PartFromJSON(
  jsonString: string,
): SafeParseResult<MessageEventV2Part, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageEventV2Part$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageEventV2Part' from JSON`,
  );
}

/** @internal */
export const MessageEventV2ReplyTo$inboundSchema: z.ZodMiniType<
  MessageEventV2ReplyTo,
  unknown
> = z.pipe(
  z.object({
    message_id: types.optional(types.string()),
    part_index: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "message_id": "messageId",
      "part_index": "partIndex",
    });
  }),
);
/** @internal */
export type MessageEventV2ReplyTo$Outbound = {
  message_id?: string | undefined;
  part_index?: number | undefined;
};

/** @internal */
export const MessageEventV2ReplyTo$outboundSchema: z.ZodMiniType<
  MessageEventV2ReplyTo$Outbound,
  MessageEventV2ReplyTo
> = z.pipe(
  z.object({
    messageId: z.optional(z.string()),
    partIndex: z.optional(z.int()),
  }),
  z.transform((v) => {
    return remap$(v, {
      messageId: "message_id",
      partIndex: "part_index",
    });
  }),
);

export function messageEventV2ReplyToToJSON(
  messageEventV2ReplyTo: MessageEventV2ReplyTo,
): string {
  return JSON.stringify(
    MessageEventV2ReplyTo$outboundSchema.parse(messageEventV2ReplyTo),
  );
}
export function messageEventV2ReplyToFromJSON(
  jsonString: string,
): SafeParseResult<MessageEventV2ReplyTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageEventV2ReplyTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageEventV2ReplyTo' from JSON`,
  );
}

/** @internal */
export const MessageEventV2Type$inboundSchema: z.ZodMiniEnum<
  typeof MessageEventV2Type
> = z.enum(MessageEventV2Type);
/** @internal */
export const MessageEventV2Type$outboundSchema: z.ZodMiniEnum<
  typeof MessageEventV2Type
> = MessageEventV2Type$inboundSchema;

/** @internal */
export const MessageEventV2Effect$inboundSchema: z.ZodMiniType<
  MessageEventV2Effect,
  unknown
> = z.object({
  type: types.optional(MessageEventV2Type$inboundSchema),
  name: types.optional(types.string()),
});
/** @internal */
export type MessageEventV2Effect$Outbound = {
  type?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const MessageEventV2Effect$outboundSchema: z.ZodMiniType<
  MessageEventV2Effect$Outbound,
  MessageEventV2Effect
> = z.object({
  type: z.optional(MessageEventV2Type$outboundSchema),
  name: z.optional(z.string()),
});

export function messageEventV2EffectToJSON(
  messageEventV2Effect: MessageEventV2Effect,
): string {
  return JSON.stringify(
    MessageEventV2Effect$outboundSchema.parse(messageEventV2Effect),
  );
}
export function messageEventV2EffectFromJSON(
  jsonString: string,
): SafeParseResult<MessageEventV2Effect, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageEventV2Effect$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageEventV2Effect' from JSON`,
  );
}

/** @internal */
export const MessageEventV2Service$inboundSchema: z.ZodMiniEnum<
  typeof MessageEventV2Service
> = z.enum(MessageEventV2Service);
/** @internal */
export const MessageEventV2Service$outboundSchema: z.ZodMiniEnum<
  typeof MessageEventV2Service
> = MessageEventV2Service$inboundSchema;

/** @internal */
export const MessageEventV2PreferredService$inboundSchema: z.ZodMiniEnum<
  typeof MessageEventV2PreferredService
> = z.enum(MessageEventV2PreferredService);
/** @internal */
export const MessageEventV2PreferredService$outboundSchema: z.ZodMiniEnum<
  typeof MessageEventV2PreferredService
> = MessageEventV2PreferredService$inboundSchema;

/** @internal */
export const MessageEventV2$inboundSchema: z.ZodMiniType<
  MessageEventV2,
  unknown
> = z.pipe(
  z.object({
    chat: z.lazy(() => MessageEventV2Chat$inboundSchema),
    id: types.string(),
    idempotency_key: z.optional(z.nullable(types.string())),
    direction: Direction$inboundSchema,
    sender_handle: ChatHandle$inboundSchema,
    parts: z.array(
      z.union([
        SchemasTextPartResponse$inboundSchema,
        SchemasMediaPartResponse$inboundSchema,
      ]),
    ),
    sent_at: z.optional(z.nullable(types.date())),
    delivered_at: z.optional(z.nullable(types.date())),
    read_at: z.optional(z.nullable(types.date())),
    reply_to: z.optional(
      z.nullable(z.lazy(() => MessageEventV2ReplyTo$inboundSchema)),
    ),
    effect: z.optional(
      z.nullable(z.lazy(() => MessageEventV2Effect$inboundSchema)),
    ),
    service: MessageEventV2Service$inboundSchema,
    preferred_service: z.optional(
      z.nullable(MessageEventV2PreferredService$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "idempotency_key": "idempotencyKey",
      "sender_handle": "senderHandle",
      "sent_at": "sentAt",
      "delivered_at": "deliveredAt",
      "read_at": "readAt",
      "reply_to": "replyTo",
      "preferred_service": "preferredService",
    });
  }),
);
/** @internal */
export type MessageEventV2$Outbound = {
  chat: MessageEventV2Chat$Outbound;
  id: string;
  idempotency_key?: string | null | undefined;
  direction: string;
  sender_handle: ChatHandle$Outbound;
  parts: Array<
    SchemasTextPartResponse$Outbound | SchemasMediaPartResponse$Outbound
  >;
  sent_at?: string | null | undefined;
  delivered_at?: string | null | undefined;
  read_at?: string | null | undefined;
  reply_to?: MessageEventV2ReplyTo$Outbound | null | undefined;
  effect?: MessageEventV2Effect$Outbound | null | undefined;
  service: string;
  preferred_service?: string | null | undefined;
};

/** @internal */
export const MessageEventV2$outboundSchema: z.ZodMiniType<
  MessageEventV2$Outbound,
  MessageEventV2
> = z.pipe(
  z.object({
    chat: z.lazy(() => MessageEventV2Chat$outboundSchema),
    id: z.string(),
    idempotencyKey: z.optional(z.nullable(z.string())),
    direction: Direction$outboundSchema,
    senderHandle: ChatHandle$outboundSchema,
    parts: z.array(
      z.union([
        SchemasTextPartResponse$outboundSchema,
        SchemasMediaPartResponse$outboundSchema,
      ]),
    ),
    sentAt: z.optional(
      z.nullable(z.pipe(z.date(), z.transform(v => v.toISOString()))),
    ),
    deliveredAt: z.optional(
      z.nullable(z.pipe(z.date(), z.transform(v => v.toISOString()))),
    ),
    readAt: z.optional(
      z.nullable(z.pipe(z.date(), z.transform(v => v.toISOString()))),
    ),
    replyTo: z.optional(
      z.nullable(z.lazy(() => MessageEventV2ReplyTo$outboundSchema)),
    ),
    effect: z.optional(
      z.nullable(z.lazy(() => MessageEventV2Effect$outboundSchema)),
    ),
    service: MessageEventV2Service$outboundSchema,
    preferredService: z.optional(
      z.nullable(MessageEventV2PreferredService$outboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      idempotencyKey: "idempotency_key",
      senderHandle: "sender_handle",
      sentAt: "sent_at",
      deliveredAt: "delivered_at",
      readAt: "read_at",
      replyTo: "reply_to",
      preferredService: "preferred_service",
    });
  }),
);

export function messageEventV2ToJSON(messageEventV2: MessageEventV2): string {
  return JSON.stringify(MessageEventV2$outboundSchema.parse(messageEventV2));
}
export function messageEventV2FromJSON(
  jsonString: string,
): SafeParseResult<MessageEventV2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageEventV2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageEventV2' from JSON`,
  );
}
