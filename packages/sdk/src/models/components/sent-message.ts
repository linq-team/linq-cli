/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as discriminatedUnionTypes from "../../types/discriminated-union.js";
import { discriminatedUnion } from "../../types/discriminated-union.js";
import * as openEnums from "../../types/enums.js";
import { OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";
import {
  DeliveryStatus,
  DeliveryStatus$inboundSchema,
} from "./delivery-status.js";
import {
  MediaPartResponse,
  MediaPartResponse$inboundSchema,
} from "./media-part-response.js";
import {
  TextPartResponse,
  TextPartResponse$inboundSchema,
} from "./text-part-response.js";

/**
 * Service used to send this message
 */
export const SentMessageService = {
  IMessage: "iMessage",
  Sms: "SMS",
  Rcs: "RCS",
} as const;
/**
 * Service used to send this message
 */
export type SentMessageService = OpenEnum<typeof SentMessageService>;

/**
 * Preferred service for sending this message
 */
export const SentMessagePreferredService = {
  IMessage: "iMessage",
  Sms: "SMS",
  Rcs: "RCS",
} as const;
/**
 * Preferred service for sending this message
 */
export type SentMessagePreferredService = OpenEnum<
  typeof SentMessagePreferredService
>;

export type SentMessagePart =
  | TextPartResponse
  | MediaPartResponse
  | discriminatedUnionTypes.Unknown<"type">;

/**
 * Type of effect
 */
export const SentMessageType = {
  Screen: "screen",
  Bubble: "bubble",
} as const;
/**
 * Type of effect
 */
export type SentMessageType = OpenEnum<typeof SentMessageType>;

/**
 * iMessage effect applied to this message (screen or bubble effect)
 */
export type SentMessageEffect = {
  /**
   * Type of effect
   */
  type?: SentMessageType | undefined;
  /**
   * Name of the effect. Common values:
   *
   * @remarks
   * - Screen effects: confetti, fireworks, lasers, sparkles, celebration, hearts, love, balloons, happy_birthday, echo, spotlight
   * - Bubble effects: slam, loud, gentle, invisible
   */
  name?: string | undefined;
};

/**
 * Service type (iMessage, SMS, RCS, etc.)
 */
export const SentMessageFromHandleService = {
  IMessage: "iMessage",
  Sms: "SMS",
  Rcs: "RCS",
} as const;
/**
 * Service type (iMessage, SMS, RCS, etc.)
 */
export type SentMessageFromHandleService = OpenEnum<
  typeof SentMessageFromHandleService
>;

/**
 * Participant status
 */
export const SentMessageStatus = {
  Active: "active",
  Left: "left",
  Removed: "removed",
} as const;
/**
 * Participant status
 */
export type SentMessageStatus = OpenEnum<typeof SentMessageStatus>;

/**
 * The sender of this message as a full handle object
 */
export type SentMessageFromHandle = {
  /**
   * Unique identifier for this handle
   */
  id: string;
  /**
   * Phone number (E.164) or email address of the participant
   */
  handle: string;
  /**
   * Service type (iMessage, SMS, RCS, etc.)
   */
  service: SentMessageFromHandleService;
  /**
   * Participant status
   */
  status: SentMessageStatus | null;
  /**
   * When this participant joined the chat
   */
  joinedAt: Date;
  /**
   * When they left (if applicable)
   */
  leftAt?: Date | null | undefined;
  /**
   * Whether this handle belongs to the sender (your phone number)
   */
  isMe?: boolean | null | undefined;
};

/**
 * Indicates this message is a threaded reply to another message
 */
export type SentMessageReplyTo = {
  /**
   * The ID of the message to reply to
   */
  messageId: string;
  /**
   * The specific message part to reply to (0-based index).
   *
   * @remarks
   * Defaults to 0 (first part) if not provided.
   * Use this when replying to a specific part of a multipart message.
   */
  partIndex?: number | undefined;
};

/**
 * A message that was sent (used in CreateChat and SendMessage responses)
 */
export type SentMessage = {
  /**
   * Message identifier (UUID)
   */
  id: string;
  /**
   * Service used to send this message
   */
  service?: SentMessageService | null | undefined;
  /**
   * Preferred service for sending this message
   */
  preferredService?: SentMessagePreferredService | null | undefined;
  /**
   * Message parts in order (text and media)
   */
  parts: Array<
    | TextPartResponse
    | MediaPartResponse
    | discriminatedUnionTypes.Unknown<"type">
  >;
  /**
   * When the message was sent
   */
  sentAt: Date;
  /**
   * When the message was delivered
   */
  deliveredAt?: Date | null | undefined;
  /**
   * Current delivery status of a message
   */
  deliveryStatus: DeliveryStatus;
  /**
   * Whether the message has been read
   */
  isRead: boolean;
  /**
   * iMessage effect applied to this message (screen or bubble effect)
   */
  effect?: SentMessageEffect | null | undefined;
  /**
   * The sender of this message as a full handle object
   */
  fromHandle?: SentMessageFromHandle | null | undefined;
  replyTo?: SentMessageReplyTo | null | undefined;
};

/** @internal */
export const SentMessageService$inboundSchema: z.ZodMiniType<
  SentMessageService,
  unknown
> = openEnums.inboundSchema(SentMessageService);

/** @internal */
export const SentMessagePreferredService$inboundSchema: z.ZodMiniType<
  SentMessagePreferredService,
  unknown
> = openEnums.inboundSchema(SentMessagePreferredService);

/** @internal */
export const SentMessagePart$inboundSchema: z.ZodMiniType<
  SentMessagePart,
  unknown
> = discriminatedUnion("type", {
  text: TextPartResponse$inboundSchema,
  media: MediaPartResponse$inboundSchema,
});

export function sentMessagePartFromJSON(
  jsonString: string,
): SafeParseResult<SentMessagePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SentMessagePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SentMessagePart' from JSON`,
  );
}

/** @internal */
export const SentMessageType$inboundSchema: z.ZodMiniType<
  SentMessageType,
  unknown
> = openEnums.inboundSchema(SentMessageType);

/** @internal */
export const SentMessageEffect$inboundSchema: z.ZodMiniType<
  SentMessageEffect,
  unknown
> = z.object({
  type: types.optional(SentMessageType$inboundSchema),
  name: types.optional(types.string()),
});

export function sentMessageEffectFromJSON(
  jsonString: string,
): SafeParseResult<SentMessageEffect, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SentMessageEffect$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SentMessageEffect' from JSON`,
  );
}

/** @internal */
export const SentMessageFromHandleService$inboundSchema: z.ZodMiniType<
  SentMessageFromHandleService,
  unknown
> = openEnums.inboundSchema(SentMessageFromHandleService);

/** @internal */
export const SentMessageStatus$inboundSchema: z.ZodMiniType<
  SentMessageStatus,
  unknown
> = openEnums.inboundSchema(SentMessageStatus);

/** @internal */
export const SentMessageFromHandle$inboundSchema: z.ZodMiniType<
  SentMessageFromHandle,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    handle: types.string(),
    service: SentMessageFromHandleService$inboundSchema,
    status: z.nullable(z._default(SentMessageStatus$inboundSchema, "active")),
    joined_at: types.date(),
    left_at: z.optional(z.nullable(types.date())),
    is_me: z.optional(z.nullable(types.boolean())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "joined_at": "joinedAt",
      "left_at": "leftAt",
      "is_me": "isMe",
    });
  }),
);

export function sentMessageFromHandleFromJSON(
  jsonString: string,
): SafeParseResult<SentMessageFromHandle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SentMessageFromHandle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SentMessageFromHandle' from JSON`,
  );
}

/** @internal */
export const SentMessageReplyTo$inboundSchema: z.ZodMiniType<
  SentMessageReplyTo,
  unknown
> = z.pipe(
  z.object({
    message_id: types.string(),
    part_index: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "message_id": "messageId",
      "part_index": "partIndex",
    });
  }),
);

export function sentMessageReplyToFromJSON(
  jsonString: string,
): SafeParseResult<SentMessageReplyTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SentMessageReplyTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SentMessageReplyTo' from JSON`,
  );
}

/** @internal */
export const SentMessage$inboundSchema: z.ZodMiniType<SentMessage, unknown> = z
  .pipe(
    z.object({
      id: types.string(),
      service: z.optional(z.nullable(SentMessageService$inboundSchema)),
      preferred_service: z.optional(
        z.nullable(SentMessagePreferredService$inboundSchema),
      ),
      parts: z.array(
        discriminatedUnion("type", {
          text: TextPartResponse$inboundSchema,
          media: MediaPartResponse$inboundSchema,
        }),
      ),
      sent_at: types.date(),
      delivered_at: z.optional(z.nullable(types.date())),
      delivery_status: DeliveryStatus$inboundSchema,
      is_read: types.boolean(),
      effect: z.optional(
        z.nullable(z.lazy(() => SentMessageEffect$inboundSchema)),
      ),
      from_handle: z.optional(
        z.nullable(z.lazy(() => SentMessageFromHandle$inboundSchema)),
      ),
      reply_to: z.optional(
        z.nullable(z.lazy(() => SentMessageReplyTo$inboundSchema)),
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        "preferred_service": "preferredService",
        "sent_at": "sentAt",
        "delivered_at": "deliveredAt",
        "delivery_status": "deliveryStatus",
        "is_read": "isRead",
        "from_handle": "fromHandle",
        "reply_to": "replyTo",
      });
    }),
  );

export function sentMessageFromJSON(
  jsonString: string,
): SafeParseResult<SentMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SentMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SentMessage' from JSON`,
  );
}
