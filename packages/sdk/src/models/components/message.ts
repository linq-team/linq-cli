/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as discriminatedUnionTypes from "../../types/discriminated-union.js";
import { discriminatedUnion } from "../../types/discriminated-union.js";
import * as openEnums from "../../types/enums.js";
import { OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";
import {
  MediaPartResponse,
  MediaPartResponse$inboundSchema,
} from "./media-part-response.js";
import {
  TextPartResponse,
  TextPartResponse$inboundSchema,
} from "./text-part-response.js";

/**
 * Service used to send/receive this message
 */
export const MessageService = {
  IMessage: "iMessage",
  Sms: "SMS",
  Rcs: "RCS",
} as const;
/**
 * Service used to send/receive this message
 */
export type MessageService = OpenEnum<typeof MessageService>;

/**
 * Preferred service for sending this message
 */
export const MessagePreferredService = {
  IMessage: "iMessage",
  Sms: "SMS",
  Rcs: "RCS",
} as const;
/**
 * Preferred service for sending this message
 */
export type MessagePreferredService = OpenEnum<typeof MessagePreferredService>;

/**
 * Service type (iMessage, SMS, RCS, etc.)
 */
export const MessageFromHandleService = {
  IMessage: "iMessage",
  Sms: "SMS",
  Rcs: "RCS",
} as const;
/**
 * Service type (iMessage, SMS, RCS, etc.)
 */
export type MessageFromHandleService = OpenEnum<
  typeof MessageFromHandleService
>;

/**
 * Participant status
 */
export const MessageStatus = {
  Active: "active",
  Left: "left",
  Removed: "removed",
} as const;
/**
 * Participant status
 */
export type MessageStatus = OpenEnum<typeof MessageStatus>;

/**
 * The sender of this message as a full handle object
 */
export type MessageFromHandle = {
  /**
   * Unique identifier for this handle
   */
  id: string;
  /**
   * Phone number (E.164) or email address of the participant
   */
  handle: string;
  /**
   * Service type (iMessage, SMS, RCS, etc.)
   */
  service: MessageFromHandleService;
  /**
   * Participant status
   */
  status: MessageStatus | null;
  /**
   * When this participant joined the chat
   */
  joinedAt: Date;
  /**
   * When they left (if applicable)
   */
  leftAt?: Date | null | undefined;
  /**
   * Whether this handle belongs to the sender (your phone number)
   */
  isMe?: boolean | null | undefined;
};

export type MessagePart1 =
  | TextPartResponse
  | MediaPartResponse
  | discriminatedUnionTypes.Unknown<"type">;

/**
 * Indicates this message is a threaded reply to another message
 */
export type MessageReplyTo = {
  /**
   * The ID of the message to reply to
   */
  messageId: string;
  /**
   * The specific message part to reply to (0-based index).
   *
   * @remarks
   * Defaults to 0 (first part) if not provided.
   * Use this when replying to a specific part of a multipart message.
   */
  partIndex?: number | undefined;
};

/**
 * Type of effect
 */
export const MessageType = {
  Screen: "screen",
  Bubble: "bubble",
} as const;
/**
 * Type of effect
 */
export type MessageType = OpenEnum<typeof MessageType>;

/**
 * iMessage effect applied to this message (screen or bubble effect)
 */
export type MessageEffect1 = {
  /**
   * Type of effect
   */
  type?: MessageType | undefined;
  /**
   * Name of the effect. Common values:
   *
   * @remarks
   * - Screen effects: confetti, fireworks, lasers, sparkles, celebration, hearts, love, balloons, happy_birthday, echo, spotlight
   * - Bubble effects: slam, loud, gentle, invisible
   */
  name?: string | undefined;
};

export type Message = {
  /**
   * Unique identifier for the message
   */
  id: string;
  /**
   * ID of the chat this message belongs to
   */
  chatId: string;
  /**
   * Service used to send/receive this message
   */
  service?: MessageService | null | undefined;
  /**
   * Preferred service for sending this message
   */
  preferredService?: MessagePreferredService | null | undefined;
  /**
   * DEPRECATED: Use from_handle instead. Phone number of the message sender.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  from?: string | null | undefined;
  /**
   * The sender of this message as a full handle object
   */
  fromHandle?: MessageFromHandle | null | undefined;
  /**
   * Message parts in order (text and media)
   */
  parts?:
    | Array<
      | TextPartResponse
      | MediaPartResponse
      | discriminatedUnionTypes.Unknown<"type">
    >
    | null
    | undefined;
  replyTo?: MessageReplyTo | null | undefined;
  /**
   * Whether this message was sent by the authenticated user
   */
  isFromMe: boolean;
  /**
   * Whether the message has been delivered
   */
  isDelivered: boolean;
  /**
   * Whether the message has been read
   */
  isRead: boolean;
  /**
   * When the message was created
   */
  createdAt: Date;
  /**
   * When the message was last updated
   */
  updatedAt: Date;
  /**
   * When the message was sent
   */
  sentAt?: Date | null | undefined;
  /**
   * When the message was delivered
   */
  deliveredAt?: Date | null | undefined;
  /**
   * When the message was read
   */
  readAt?: Date | null | undefined;
  /**
   * iMessage effect applied to this message (screen or bubble effect)
   */
  effect?: MessageEffect1 | null | undefined;
};

/** @internal */
export const MessageService$inboundSchema: z.ZodMiniType<
  MessageService,
  unknown
> = openEnums.inboundSchema(MessageService);

/** @internal */
export const MessagePreferredService$inboundSchema: z.ZodMiniType<
  MessagePreferredService,
  unknown
> = openEnums.inboundSchema(MessagePreferredService);

/** @internal */
export const MessageFromHandleService$inboundSchema: z.ZodMiniType<
  MessageFromHandleService,
  unknown
> = openEnums.inboundSchema(MessageFromHandleService);

/** @internal */
export const MessageStatus$inboundSchema: z.ZodMiniType<
  MessageStatus,
  unknown
> = openEnums.inboundSchema(MessageStatus);

/** @internal */
export const MessageFromHandle$inboundSchema: z.ZodMiniType<
  MessageFromHandle,
  unknown
> = z.pipe(
  z.object({
    id: types.string(),
    handle: types.string(),
    service: MessageFromHandleService$inboundSchema,
    status: z.nullable(z._default(MessageStatus$inboundSchema, "active")),
    joined_at: types.date(),
    left_at: z.optional(z.nullable(types.date())),
    is_me: z.optional(z.nullable(types.boolean())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "joined_at": "joinedAt",
      "left_at": "leftAt",
      "is_me": "isMe",
    });
  }),
);

export function messageFromHandleFromJSON(
  jsonString: string,
): SafeParseResult<MessageFromHandle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageFromHandle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageFromHandle' from JSON`,
  );
}

/** @internal */
export const MessagePart1$inboundSchema: z.ZodMiniType<MessagePart1, unknown> =
  discriminatedUnion("type", {
    text: TextPartResponse$inboundSchema,
    media: MediaPartResponse$inboundSchema,
  });

export function messagePart1FromJSON(
  jsonString: string,
): SafeParseResult<MessagePart1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagePart1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagePart1' from JSON`,
  );
}

/** @internal */
export const MessageReplyTo$inboundSchema: z.ZodMiniType<
  MessageReplyTo,
  unknown
> = z.pipe(
  z.object({
    message_id: types.string(),
    part_index: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "message_id": "messageId",
      "part_index": "partIndex",
    });
  }),
);

export function messageReplyToFromJSON(
  jsonString: string,
): SafeParseResult<MessageReplyTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageReplyTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageReplyTo' from JSON`,
  );
}

/** @internal */
export const MessageType$inboundSchema: z.ZodMiniType<MessageType, unknown> =
  openEnums.inboundSchema(MessageType);

/** @internal */
export const MessageEffect1$inboundSchema: z.ZodMiniType<
  MessageEffect1,
  unknown
> = z.object({
  type: types.optional(MessageType$inboundSchema),
  name: types.optional(types.string()),
});

export function messageEffect1FromJSON(
  jsonString: string,
): SafeParseResult<MessageEffect1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageEffect1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageEffect1' from JSON`,
  );
}

/** @internal */
export const Message$inboundSchema: z.ZodMiniType<Message, unknown> = z.pipe(
  z.object({
    id: types.string(),
    chat_id: types.string(),
    service: z.optional(z.nullable(MessageService$inboundSchema)),
    preferred_service: z.optional(
      z.nullable(MessagePreferredService$inboundSchema),
    ),
    from: z.optional(z.nullable(types.string())),
    from_handle: z.optional(z.nullable(z.lazy(() =>
      MessageFromHandle$inboundSchema
    ))),
    parts: z.optional(
      z.nullable(
        z.array(
          discriminatedUnion("type", {
            text: TextPartResponse$inboundSchema,
            media: MediaPartResponse$inboundSchema,
          }),
        ),
      ),
    ),
    reply_to: z.optional(
      z.nullable(z.lazy(() => MessageReplyTo$inboundSchema)),
    ),
    is_from_me: types.boolean(),
    is_delivered: types.boolean(),
    is_read: types.boolean(),
    created_at: types.date(),
    updated_at: types.date(),
    sent_at: z.optional(z.nullable(types.date())),
    delivered_at: z.optional(z.nullable(types.date())),
    read_at: z.optional(z.nullable(types.date())),
    effect: z.optional(z.nullable(z.lazy(() => MessageEffect1$inboundSchema))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "chat_id": "chatId",
      "preferred_service": "preferredService",
      "from_handle": "fromHandle",
      "reply_to": "replyTo",
      "is_from_me": "isFromMe",
      "is_delivered": "isDelivered",
      "is_read": "isRead",
      "created_at": "createdAt",
      "updated_at": "updatedAt",
      "sent_at": "sentAt",
      "delivered_at": "deliveredAt",
      "read_at": "readAt",
    });
  }),
);

export function messageFromJSON(
  jsonString: string,
): SafeParseResult<Message, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message' from JSON`,
  );
}
