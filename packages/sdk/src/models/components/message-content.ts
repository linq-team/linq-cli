/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { ClosedEnum } from "../../types/enums.js";
import {
  MessageEffect,
  MessageEffect$Outbound,
  MessageEffect$outboundSchema,
} from "./message-effect.js";
import {
  MessagePart,
  MessagePart$Outbound,
  MessagePart$outboundSchema,
} from "./message-part.js";
import {
  ReplyTo,
  ReplyTo$Outbound,
  ReplyTo$outboundSchema,
} from "./reply-to.js";

/**
 * Preferred messaging service to use for this message.
 *
 * @remarks
 * If not specified, uses default fallback chain: iMessage → RCS → SMS.
 * - iMessage: Enforces iMessage without fallback to RCS or SMS. Message fails if recipient doesn't support iMessage.
 * - RCS: Enforces RCS or SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
 * - SMS: Enforces SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
 */
export const MessageContentPreferredService = {
  IMessage: "iMessage",
  Rcs: "RCS",
  Sms: "SMS",
} as const;
/**
 * Preferred messaging service to use for this message.
 *
 * @remarks
 * If not specified, uses default fallback chain: iMessage → RCS → SMS.
 * - iMessage: Enforces iMessage without fallback to RCS or SMS. Message fails if recipient doesn't support iMessage.
 * - RCS: Enforces RCS or SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
 * - SMS: Enforces SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
 */
export type MessageContentPreferredService = ClosedEnum<
  typeof MessageContentPreferredService
>;

/**
 * Message content container. Groups all message-related fields together,
 *
 * @remarks
 * separating the "what" (message content) from the "where" (routing fields like from/to).
 */
export type MessageContent = {
  /**
   * Array of message parts. Each part can be either text or media.
   *
   * @remarks
   * Parts are displayed in order. Text and media can be mixed.
   *
   * **Supported Media:**
   * - Images: .jpg, .jpeg, .png, .gif, .heic, .heif, .tif, .tiff, .bmp
   * - Videos: .mp4, .mov, .m4v, .mpeg, .mpg, .3gp
   * - Documents: .pdf, .txt, .rtf, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx, .pages, .numbers, .key, .epub, .zip, .html, .htm
   * - Contact & Calendar: .vcf, .ics
   *
   * **Audio Handling:**
   * - Audio files (voice memos) should use the dedicated `/v3/chats/{chatId}/voicememo` endpoint
   * - This ensures proper voice memo formatting and playback in iMessage
   *
   * **Validation Rule:** Consecutive text parts are not allowed. Text parts must
   * be separated by media parts. For example, [text, text] is invalid, but
   * [text, media, text] is valid.
   */
  parts: Array<MessagePart>;
  /**
   * iMessage effect applied to a message (screen or bubble effect)
   */
  effect?: MessageEffect | undefined;
  /**
   * Indicates this message is a threaded reply to another message
   */
  replyTo?: ReplyTo | undefined;
  /**
   * Optional idempotency key for this message.
   *
   * @remarks
   * Use this to prevent duplicate sends of the same message.
   */
  idempotencyKey?: string | undefined;
  /**
   * Preferred messaging service to use for this message.
   *
   * @remarks
   * If not specified, uses default fallback chain: iMessage → RCS → SMS.
   * - iMessage: Enforces iMessage without fallback to RCS or SMS. Message fails if recipient doesn't support iMessage.
   * - RCS: Enforces RCS or SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
   * - SMS: Enforces SMS (no iMessage). Uses RCS if recipient supports it, otherwise falls back to SMS.
   */
  preferredService?: MessageContentPreferredService | undefined;
};

/** @internal */
export const MessageContentPreferredService$outboundSchema: z.ZodMiniEnum<
  typeof MessageContentPreferredService
> = z.enum(MessageContentPreferredService);

/** @internal */
export type MessageContent$Outbound = {
  parts: Array<MessagePart$Outbound>;
  effect?: MessageEffect$Outbound | undefined;
  reply_to?: ReplyTo$Outbound | undefined;
  idempotency_key?: string | undefined;
  preferred_service?: string | undefined;
};

/** @internal */
export const MessageContent$outboundSchema: z.ZodMiniType<
  MessageContent$Outbound,
  MessageContent
> = z.pipe(
  z.object({
    parts: z.array(MessagePart$outboundSchema),
    effect: z.optional(MessageEffect$outboundSchema),
    replyTo: z.optional(ReplyTo$outboundSchema),
    idempotencyKey: z.optional(z.string()),
    preferredService: z.optional(MessageContentPreferredService$outboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      replyTo: "reply_to",
      idempotencyKey: "idempotency_key",
      preferredService: "preferred_service",
    });
  }),
);

export function messageContentToJSON(messageContent: MessageContent): string {
  return JSON.stringify(MessageContent$outboundSchema.parse(messageContent));
}
